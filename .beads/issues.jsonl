{"id":"geolog-0jh","title":"Full axiom reconstruction in structure_to_theory","notes":"src/meta.rs:828 - structure_to_theory() returns empty axioms vec with 'TODO: Full axiom reconstruction'.\n\nNeed to walk the GeologMeta structure to reconstruct Sequent → Formula → Term AST. Required for loading saved theories.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:34.449414106Z","created_by":"davidad","updated_at":"2026-01-19T15:51:34.449414106Z"}
{"id":"geolog-0vd","title":"Solver API design sketch","description":"Design the agent-facing API for driving search (davidad's vision).\n\nCore concepts:\n- Goal: geometric sequent to witness\n- SearchState: partial assignments, undo trail (Floyd's reversible memory)\n- Tactic trait: decompose goal into subgoals\n\nBuilt-in tactics:\n- Instantiate: pick witnesses for existentials\n- SatFill: hand off to batsat for finite completion of partial functions\n- Unfold: expand theory definitions\n- ApplyAxiom: use a theory axiom\n\nKey references:\n- Knuth 4B: Algorithm D for CSP, Dancing Cells\n- Logic-Based Benders decomposition (CDCL as special case)\n- batsat crate for Boolean satisfiability\n\nThe tensor machinery (TensorExpr, check_sequent) provides the constraint checking substrate. The solver sits on top, guiding search.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:09:09.460777853Z","updated_at":"2025-12-15T02:34:13.370291896Z","closed_at":"2025-12-15T02:34:13.370291896Z","dependencies":[{"issue_id":"geolog-0vd","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:09:28.987309673Z","created_by":"dev"}]}
{"id":"geolog-0ya","title":"Incremental axiom checking for patches","description":"When a patch adds tuples to a relation, only re-check relevant axioms.\n\nCALM insight: monotone patches + geometric logic = only need to check if new tuples made antecedent true without consequent being true.\n\nAlgorithm:\n1. Track axiom→relation dependencies (which relations appear in antecedent)\n2. On patch adding tuple (a,b,...) to relation R:\n   - Find axioms with R in antecedent\n   - For each: check substitutions involving (a,b,...)\n   - Report violations or (for derived relations) trigger forward chaining\n\nThis is semi-naive Datalog evaluation for the special case of monotone patches.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:00.766060992Z","updated_at":"2025-12-15T02:08:00.766060992Z","dependencies":[{"issue_id":"geolog-0ya","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:08:44.370614869Z","created_by":"dev"}]}
{"id":"geolog-1d4","title":"Nested instance elaboration","description":"elaborate_instance returns 'unsupported feature: nested instance' for inline instance definitions like 'initial_marking = { t : token; t token/of = A; }'. Need to recursively elaborate and properly link nested structures.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:09.300786049Z","updated_at":"2025-12-15T00:45:09.300786049Z"}
{"id":"geolog-1wv","title":"Confusing error message when referencing undefined theory","description":"When creating an instance with a non-existent theory (e.g., 'instance I : NonexistentTheory = {...}'), the error message says 'unknown sort: NonexistentTheory' instead of 'unknown theory: NonexistentTheory'. This is confusing because the user is trying to reference a theory, not a sort.\n\nExample:\n```\ninstance BadInstance : NonexistentTheory = { x : Sort; }\nError: Elaboration error: unknown sort: NonexistentTheory\n```\n\nExpected: 'Error: unknown theory: NonexistentTheory'\n\nLocation: src/elaborate.rs (type_expr_to_theory_name or instance elaboration)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:43:20.191143097Z","updated_at":"2025-12-14T23:01:50.22790128Z","closed_at":"2025-12-14T23:01:50.22790378Z"}
{"id":"geolog-2ir","title":"Unified copy-on-write structure loading","design":"Always load MappedStructure (immutable zero-copy base). Mutations create a WorkingStructure that holds patches/deltas on top of the base. Reads check patch layer first, fall back to base. Commit materializes patches into new immutable structure. This unifies the loading story and naturally supports undo/rollback.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T13:50:55.60169436Z","created_by":"davidad","updated_at":"2026-01-19T14:21:14.615027243Z","closed_at":"2026-01-19T14:21:14.615027243Z","close_reason":"Implemented OverlayStructure in src/overlay.rs - patch-on-write system that always loads MappedStructure as immutable base, accumulates mutations in StructureDelta, reads check delta first then fall back to base, commit materializes to new MappedStructure. Includes 9 proptests in tests/proptest_overlay.rs verifying overlay reads match committed structure."}
{"id":"geolog-386","title":"Deep AST equality for roundtrip tests","description":"From ROADMAP.md: Recursive comparison for AST roundtrip tests. Currently pretty-print tests just check that parsing succeeds, not that the AST is equivalent.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:01.210591756Z","updated_at":"2025-12-15T00:49:01.210591756Z"}
{"id":"geolog-3cc","title":"Compile core::Formula to TensorExpr","description":"Bridge from elaborated formulas to tensor evaluation.\n\nNeed to traverse core::Formula and emit TensorExpr:\n- RelF(rel_id, terms) → Leaf tensor from structure.relations[rel_id], with variable bindings from terms\n- Conj([φ, ψ, ...]) → conjunction_all() \n- Disj([φ, ψ, ...]) → need to add disjunction support (pointwise OR)\n- Exists(var, φ) → exists(φ_expr, var)\n- Eq(t1, t2) → diagonal constraint (identity tensor contracted)\n- True → scalar(true)\n- False → scalar(false)\n\nKey consideration: variable names come from the Formula's context, need to thread through consistently.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:29.320693546Z","updated_at":"2025-12-15T02:25:51.202125726Z","closed_at":"2025-12-15T02:25:51.202125726Z","dependencies":[{"issue_id":"geolog-3cc","depends_on_id":"geolog-dr6","type":"blocks","created_at":"2025-12-15T02:08:39.275188263Z","created_by":"dev"}]}
{"id":"geolog-3pa","title":"Duplicate theory names silently overwrite","description":"Defining a theory with a name that already exists silently replaces the old theory without any warning or error.\n\nExample:\n```\ntheory T1 { X : Sort; }\ntheory T1 { Y : Sort; }  // Silently replaces the first T1\n```\n\nThis can lead to confusion and unintended behavior. The REPL should either:\n1. Reject duplicate names with an error\n2. Warn the user and ask for confirmation\n3. Use a versioning/shadowing approach with clear indication\n\nLocation: src/repl.rs (execute_geolog, theory registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:43.845301347Z","updated_at":"2025-12-15T00:02:05.64745744Z","closed_at":"2025-12-15T00:02:05.64745744Z"}
{"id":"geolog-4kk","title":"Add RelationPatch to patch.rs","description":"Patch type is missing relation changes. ElementPatch and FunctionPatch exist, but relations can also be asserted/retracted. Add RelationPatch with assertions/retractions (by UUID tuples), update Patch struct, and update diff/apply_patch functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T03:45:40.158190009Z","updated_at":"2026-01-19T01:56:39.44419015Z","closed_at":"2026-01-19T01:56:39.44419015Z","close_reason":"Added RelationPatch struct with assertions/retractions, updated Patch struct with num_relations field, implemented relation diffing and application in diff() and apply_patch(), with full inversion support."}
{"id":"geolog-4ww","title":"Relation semantics","description":"Relations exist in Signature and can be declared in theories, but there's no runtime representation in Structure. Need to add relation storage (likely RoaringTreemap for each relation's extent) and evaluation for RelF formulas.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:21.340217502Z","updated_at":"2025-12-15T01:32:54.076075002Z","closed_at":"2025-12-15T01:32:54.076075002Z"}
{"id":"geolog-5zt","title":"Query execution stub","description":"The REPL returns 'Queries not yet implemented' for query declarations. Need to design and implement the entry point for the solver API - turning a QueryDecl into a Goal that the search machinery can work on.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:23.044058015Z","updated_at":"2025-12-15T00:50:22.951103236Z","dependencies":[{"issue_id":"geolog-5zt","depends_on_id":"geolog-py9","type":"blocks","created_at":"2025-12-15T00:48:19.228400368Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-yi1","type":"blocks","created_at":"2025-12-15T00:48:24.321393995Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-1d4","type":"blocks","created_at":"2025-12-15T00:48:29.40937604Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-xj2","type":"blocks","created_at":"2025-12-15T04:07:56.271359664Z","created_by":"dev"}]}
{"id":"geolog-7cc","title":"Product sorts (record types) hidden in :inspect","description":"When inspecting a theory with product sorts (record types), they are counted in the sort count but not displayed in the output.\n\nExample:\n```\ntheory WithProduct {\n    X : Sort;\n    Y : Sort;\n    Pair : [fst : X, snd : Y] Sort;\n}\n\n:inspect WithProduct\nOutput shows: X : Sort; Y : Sort;  (only 2 of 3 sorts shown)\nExpected: Should also show Pair : [fst : X, snd : Y] Sort;\n```\n\nThe theory shows '2 sorts' in the count but Pair is being counted somewhere and not displayed.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","design":"Add syntax for named product sorts, e.g. 'Pair : Sort = [fst : X, snd : Y];'. This would require: (1) Parser changes to support this new sort declaration syntax, (2) Elaboration logic to create a sort with product structure, (3) Pretty-printer support. Currently record types only exist as relation domains or in-line product types within function signatures.","notes":"Reclassified as feature request per investigation. Would require new parser/elaboration support for syntax like 'Pair : Sort = [fst : X, snd : Y];'. The label feature-request was already added.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:46:17.713086239Z","updated_at":"2025-12-15T00:49:55.697516521Z","labels":["feature-request","syntax"]}
{"id":"geolog-7f1","title":"Wire Store to REPL and deprecate workspace.rs","notes":"The Store architecture (src/store/) implements GeologMeta-as-source-of-truth with append-only, patch-based versioning. But it's not wired up to the rest of the system yet.\n\nMigration needed:\n1. Wire REPL (src/repl.rs) to use Store instead of workspace\n2. Wire bin/geolog.rs commands (:commit, :add, :assert, :retract, :history) to Store\n3. Update elaborate/instance.rs to use Store\n4. Update overlay.rs to work with Store\n5. Eventually deprecate/remove workspace.rs\n\nFiles still using workspace.rs:\n- src/repl.rs\n- src/bin/geolog.rs  \n- src/elaborate/instance.rs\n- src/overlay.rs\n- src/zerocopy.rs","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:50:50.19462555Z","created_by":"davidad","updated_at":"2026-01-19T16:07:41.206771994Z","closed_at":"2026-01-19T16:07:41.206771994Z","close_reason":"Store is now wired to the REPL. ReplState uses Store as source of truth with transitional theories/instances HashMaps for elaboration. Commands :commit, :history, :add, :assert, :retract all work. Workspace.rs deprecated. All tests pass."}
{"id":"geolog-7rn","title":"Pending equations tracking in solver","description":"Add PendingEquation type to solver. When CheckTactic finds an equation consequent, or when function values conflict, create a pending equation instead of treating as error. Equations feed into congruence closure.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:18.765134027Z","updated_at":"2026-01-19T01:52:24.44555405Z","closed_at":"2026-01-19T01:52:24.44555405Z","close_reason":"PendingEquation type added to solver/types.rs with lhs/rhs Slid fields and EquationReason enum (FunctionConflict, AxiomConsequent, UserAsserted, Congruence). Integrated with CongruenceClosure which manages a VecDeque\u003cPendingEquation\u003e.","dependencies":[{"issue_id":"geolog-7rn","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:03.840723585Z","created_by":"dev"}]}
{"id":"geolog-7tt","title":"Query engine with chase algorithm","design":"The core missing piece: a fixpoint engine that evaluates Datalog-style geometric axioms. Components needed:\n\n1. Stratification analysis - detect positive/negative recursion, compute strata\n2. Semi-naive evaluation - incremental fixpoint computation\n3. Chase algorithm - for existential conclusions (Skolemization or witness generation)\n4. Materialization vs on-demand - when to precompute derived relations\n5. Termination guarantees - detect non-terminating theories\n\nThe ancestor relation in GeologMeta is a good test case. Should integrate with VecRelation storage for efficient delta iteration.","status":"open","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:55.387812869Z","created_by":"davidad","updated_at":"2026-01-19T15:38:20.744018897Z"}
{"id":"geolog-8sc","title":"Update stale comment on Formula::Rel","notes":"src/core.rs line 329 says 'Relation (currently unused — geometric logic often encodes via equations)' but Formula::Rel is heavily used in meta.rs, tensor/check.rs, tensor/compile.rs, repl.rs, elaborate/env.rs. Just delete the misleading comment.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:36.463055681Z","created_by":"davidad","updated_at":"2026-01-19T15:45:38.476185074Z","closed_at":"2026-01-19T15:45:38.476185074Z","close_reason":"Fixed stale comment in core.rs:328"}
{"id":"geolog-8z9","title":"State management and naming refactoring","description":"Consolidate REPL's Env and Workspace into a single source of truth, and overhaul NamingIndex with reverse-path BTreeMap for efficient suffix-based lookup.\n\nSee: loose_thoughts/2025-12-15_09:40_state_and_naming_refactor.md","design":"Radical simplification: eliminate ElaboratedTheory (almost entirely).\n\nBootstrap sequence:\n1. Parse GeologMeta.geolog → AST\n2. Elaborate → ElaboratedTheory (ONLY use of this type)\n3. Convert via theory_to_structure() → primordial GeologMeta instance\n4. From then on, everything is Structure queries\n\nKey components:\n- Workspace holds: Universe, NamingIndex (with reverse-path BTreeMap), GeologMeta Structure, user instances\n- ElaboratedTheory/Signature/Theory become bootstrap-only types\n- NamingIndex maps ALL UUIDs (theories, sorts, funcs, instances, elements) via reversed paths\n- Cross-instance refs like \"ExampleNet/A\" become BTreeMap suffix lookups\n\nMigration phases:\n1. NamingIndex: add ReversedPath BTreeMap\n2. Workspace: hold GeologMeta Structure instead of HashMap\u003cString, Rc\u003cElaboratedTheory\u003e\u003e\n3. Elaboration: emit directly to GeologMeta Structure (not ElaboratedTheory)\n4. ReplState: thin wrapper around Workspace\n5. Cross-instance references via NamingIndex","notes":"Phase 1 COMPLETE (commit d5c57a3): NamingIndex with ReversedPath BTreeMap\n\nPhase 2 COMPLETE (commit 38f2134): Unified Workspace\n- Workspace owns: universe, naming, meta, instances, theories\n- InstanceEntry holds structure + element name mappings\n- ReplState is thin wrapper around Workspace\n- resolve_element() provides unified name resolution for cross-instance refs\n- resolve_in_instance() for param-qualified lookups\n\nNext: Wire elaborate_instance to use Workspace.resolve_element() for cross-instance references. Then yi1 is fully solved and we can close it.\n\nRemaining from original design:\n- Phase 3: elaborate_theory to mutate workspace.meta directly (not ElaboratedTheory)\n- Phase 4: full ElaboratedTheory elimination (bootstrap-only)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-15T09:41:48.891488701Z","updated_at":"2026-01-19T15:50:37.349092545Z","closed_at":"2026-01-19T15:50:37.349092545Z","close_reason":"Superseded by store/ module architecture. The Store struct in src/store/mod.rs implements the vision of this epic (GeologMeta as single source of truth, append-only, patch-based versioning). New epic needed to wire Store to REPL and deprecate workspace.rs."}
{"id":"geolog-9k9","title":"Axiom checking / constraint propagation","description":"Axioms (sequents) are stored but never evaluated. Need infrastructure to: (1) check if an axiom is satisfied by a structure, (2) propagate constraints when partial assignments are made, (3) detect conflicts early. This connects to the CALM theorem insight - only need to check new potential violations from new patches.","notes":"Progress update: Implemented lazy tensor expressions (TensorExpr) with fusion.\n\nKey insight: TensorExpr builds expression tree; Contract(Product(...)) fuses into hash join without materializing Cartesian product.\n\nImplemented:\n- SparseTensor (materialized BTreeSet\u003cVec\u003cusize\u003e\u003e)\n- TensorExpr::Leaf | Product | Contract (lazy)\n- fused_join with hash join for 2-way case\n- conjunction() and exists() helpers for variable alignment\n- 7 tests passing including large sparse join\n\nNext: compile core::Formula → TensorExpr, then check_sequent","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:44.924943873Z","updated_at":"2025-12-15T02:32:54.742909783Z","closed_at":"2025-12-15T02:32:54.742909783Z","dependencies":[{"issue_id":"geolog-9k9","depends_on_id":"geolog-4ww","type":"blocks","created_at":"2025-12-15T00:48:39.614746335Z","created_by":"dev"}]}
{"id":"geolog-bng","title":"Implement Store::load properly","notes":"src/store/mod.rs:229 - Store::load() just creates a new empty store:\n\n  pub fn load(path: \u0026Path) -\u003e Result\u003cSelf, String\u003e {\n      // TODO: Implement proper loading\n      Ok(Self::with_path(path))\n  }\n\nShould deserialize the persisted GeologMeta structure, universe, naming index, and reconstruct head/uncommitted state.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:42.641061417Z","created_by":"davidad","updated_at":"2026-01-19T15:51:42.641061417Z","dependencies":[{"issue_id":"geolog-bng","depends_on_id":"geolog-7f1","type":"parent-child","created_at":"2026-01-19T15:52:02.732907266Z","created_by":"davidad"}]}
{"id":"geolog-bpd","title":"Leapfrog Triejoin for multi-way joins","description":"Current fused_join uses hash join for 2-way, nested loops for 3+ way.\n\nLeapfrog Triejoin is worst-case optimal for multi-way joins. Requires:\n- Relations sorted by each variable order (multiple indexes)\n- 'seek' operation: given column and bound, find next value ≥ bound\n- Iterators that can 'leapfrog' to sync up across relations\n\nReferences:\n- Veldhuizen 2014: 'Leapfrog Triejoin: A Simple, Worst-Case Optimal Join Algorithm'\n- LogicBlox / RelationalAI implementations\n\nWould replace CartesianProductIter fallback in fused_join for 3+ relations.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:56.518803879Z","updated_at":"2025-12-15T02:08:56.518803879Z"}
{"id":"geolog-cbd","title":"Function signatures shown as '...' in theory inspection","description":"When using ':inspect TheoryName' to view a theory, function signatures are shown as '...' instead of their actual type signatures.\n\nExample:\n```\ntheory Graph {\n    V : Sort;\n    E : Sort;\n    src : E -\u003e V;\n    tgt : E -\u003e V;\n}\n\n:inspect Graph\nOutput shows: src : ...; tgt : ...;\nExpected: src : E -\u003e V; tgt : E -\u003e V;\n```\n\nLocation: src/repl.rs (format_theory_for_display or similar)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:43:46.702440405Z","updated_at":"2025-12-14T23:02:08.731222991Z","closed_at":"2025-12-14T23:02:08.731224449Z"}
{"id":"geolog-crk","title":"Relations not counted in :list theories summary","description":"When listing theories with ':list theories', the summary shows counts for sorts, functions, and axioms, but not relations.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:list theories\nOutput: WithRelation (1 sorts, 0 functions, 0 axioms)\nExpected: WithRelation (1 sorts, 0 functions, 1 relations, 0 axioms)\n```\n\nThis is a minor issue but makes relations feel like second-class citizens in the type system.\n\nLocation: src/repl.rs (list_theories or TheoryInfo)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:45:58.654532341Z","updated_at":"2025-12-15T00:02:23.801766158Z","closed_at":"2025-12-15T00:02:23.801766158Z"}
{"id":"geolog-d0b","title":"Parameterized theories don't show parameters in :inspect","description":"When inspecting a parameterized theory, the parameter list is not shown in the output.\n\nExample:\n```\ntheory (N : PetriNet instance) Marking {\n    token : Sort;\n}\n\n:inspect Marking\nOutput shows: theory Marking { token : Sort; }\nExpected: theory (N : PetriNet instance) Marking { token : Sort; }\n```\n\nThe parameter information is lost in the display, making it unclear that this is a parameterized theory.\n\nLocation: src/repl.rs (theory formatting)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:05.212783874Z","updated_at":"2025-12-15T00:01:55.559419526Z","closed_at":"2025-12-15T00:01:55.559419526Z"}
{"id":"geolog-dkk","title":"Derivation search for False","description":"Implement search for derivations of ⊢ False from instantiated axioms. When pending equations are merged, check if any axiom with False as consequent has its premise satisfied. This is the only way to detect true unsatisfiability in geometric logic. See Derivation.lean in model-theory-topos for reference.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:09.104194054Z","updated_at":"2025-12-15T04:06:09.104194054Z","dependencies":[{"issue_id":"geolog-dkk","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:58.72989683Z","created_by":"dev"},{"issue_id":"geolog-dkk","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:24.662048457Z","created_by":"dev"}]}
{"id":"geolog-dr6","title":"Disjunction support in TensorExpr","description":"Currently TensorExpr only has Product (AND). Need Disjunction (OR) for full formula support.\n\nOptions:\n1. Add TensorExpr::Sum variant (lazy union of extents)\n2. Handle at compile time by expanding? (bad for large disjunctions)\n\nSum(Vec\u003cTensorExpr\u003e) with same dimensions → union of extents.\nFusion opportunity: Contract(Sum(...)) can distribute.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:51.22924934Z","updated_at":"2025-12-15T02:21:00.378783288Z","closed_at":"2025-12-15T02:21:00.378783288Z"}
{"id":"geolog-ef2","title":"Handle schema changes in patch diffing","notes":"src/patch.rs:283 - When diffing structures, if a function exists in new but not old (schema change), we skip it. Should properly handle schema evolution in patches.\n\nContext: 'continue; // TODO: handle schema changes'","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:18.343416955Z","created_by":"davidad","updated_at":"2026-01-19T15:51:18.343416955Z"}
{"id":"geolog-far","title":"check_sequent implementation","description":"Given a Sequent and Structure, check if the axiom is satisfied.\n\nFor sequent '∀ctx. ante ⊢ conseq':\n1. compile ante → TensorExpr (over ctx variables)\n2. compile conseq → TensorExpr (over ctx variables)  \n3. check: every tuple in ante.materialize() is also in conseq\n\nCan short-circuit on first violation.\n\nFor geometric logic, conseq is positive (no negation), so this is straightforward subset check. Violations are tuples where ante is true but conseq is false.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:41.508562065Z","updated_at":"2025-12-15T02:31:07.980264916Z","closed_at":"2025-12-15T02:31:07.980264916Z","dependencies":[{"issue_id":"geolog-far","depends_on_id":"geolog-3cc","type":"blocks","created_at":"2025-12-15T02:08:34.180308033Z","created_by":"dev"}]}
{"id":"geolog-fjy","title":"Congruence closure for equation handling","description":"Implement union-find with path compression for tracking element equivalences. When equations are created (from function conflicts or axiom consequents), merge equivalence classes and propagate through function applications. This is the EUF (equality + uninterpreted functions) core.","notes":"Added CongruenceClosure to SearchNode with union-find, pending equation queue, merge/find/are_equal methods. Tests passing. Next: propagation through functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:05:46.937966821Z","updated_at":"2026-01-19T01:51:38.871919901Z","closed_at":"2026-01-19T01:51:38.871919901Z","close_reason":"Implemented CongruenceClosure struct with union-find, PendingEquation queue, and integration with SearchNode in solver/types.rs","dependencies":[{"issue_id":"geolog-fjy","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:53.635588612Z","created_by":"dev"}]}
{"id":"geolog-h7m","title":"Expand GeologMeta with Derivation proof term syntax","notes":"Add proof term / derivation sorts to GeologMeta.geolog, mirroring Lean's Derivation.lean structure.\n\nProposed sorts:\n- Derivation : Sort\n- Derivation/context : Derivation -\u003e FormulaCtx\n- Derivation/conclusion : Derivation -\u003e Formula\n\nConstructor sorts (each embeds into Derivation):\n- AxiomD, VarD, TrueIntroD, FalseElimD\n- ConjIntroD, ConjElimLD, ConjElimRD  \n- DisjIntroD, DisjElimD\n- EqIntroD, EqElimD\n- ExistsIntroD, ExistsElimD\n\nEach constructor has pointers to sub-derivations and metadata (which axiom, which witness term, etc.)\n\nUse cases:\n1. Query result provenance / explanation\n2. Certified export to Lean for verification\n3. Geometric morphism implementation (need to track HOW formulas map)\n\nDepends on: query engine basics (geolog-7tt) - derivation structure should be informed by what the chase produces.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:58.766688914Z","created_by":"davidad","updated_at":"2026-01-19T15:41:58.766688914Z","dependencies":[{"issue_id":"geolog-h7m","depends_on_id":"geolog-7tt","type":"blocks","created_at":"2026-01-19T15:42:17.885559151Z","created_by":"davidad"},{"issue_id":"geolog-h7m","depends_on_id":"geolog-or6","type":"related","created_at":"2026-01-19T15:42:23.057502465Z","created_by":"davidad"}]}
{"id":"geolog-jho","title":"Support infinitary disjunctions","notes":"core.rs Formula::Disj(Vec\u003cFormula\u003e) only supports finite disjunction. The Lean formalization has:\n\n  infdisj {xs} {I : Set κ} : (I → Formula xs) → Formula xs\n\nwhere κ is a SmallUniverse indexing type.\n\nFor geometric logic completeness, we need infinitary disjunctions. But:\n1. For finite model theory (databases), finite disjunction suffices\n2. Infinitary disjunction matters for: classifying toposes, infinite Skolemization, some program analysis theories\n3. Implementation options: lazy/streaming disjuncts, symbolic index sets\n\nDefer until we have a concrete use case requiring infinite disjunction. Most database/workflow applications will be finite.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:52.067602427Z","created_by":"davidad","updated_at":"2026-01-19T15:41:52.067602427Z"}
{"id":"geolog-lbn","title":"Consider de Bruijn indices for Term representation","notes":"core.rs Term::Var uses names (String, DerivedSort) for 'debuggability'. The Lean formalization uses positional indices for alpha-equivalence.\n\nQuestions to resolve:\n1. Do we need alpha-equivalence in the Rust implementation? (Probably not - we're querying concrete instances, not proving metatheorems)\n2. If we do need term comparison, could hash-cons with explicit name binding be enough?\n3. Performance: String comparison vs integer comparison in hot paths\n\nCurrent assessment: Names are probably fine for an implementation focused on query evaluation. de Bruijn would matter more if we were implementing a proof checker or term rewriter. Low priority unless profiling shows name comparison is a bottleneck.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:46.343016685Z","created_by":"davidad","updated_at":"2026-01-19T15:41:46.343016685Z"}
{"id":"geolog-m0c","title":"Product domain support across codebase","notes":"Multiple places skip product domains with TODOs:\n\n1. src/solver/tree.rs:311 - Solver skips product domains when checking function completeness\n2. src/meta.rs:684 - MetaReader.find_by_func skips product domains  \n3. src/tensor/compile.rs:155 - Tensor compilation skips nested product sorts\n\nThese should be addressed together since they're all about the same gap.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:24.715123749Z","created_by":"davidad","updated_at":"2026-01-19T15:51:24.715123749Z","dependencies":[{"issue_id":"geolog-m0c","depends_on_id":"geolog-7cc","type":"related","created_at":"2026-01-19T15:52:07.893037101Z","created_by":"davidad"}]}
{"id":"geolog-or6","title":"Derivations as meta-embedded proof terms","design":"Proof terms for geometric sequents, meta-embedded like GeologMeta. Key design questions:\n\n1. When are explicit derivations needed?\n   - Provenance/explanation of query results\n   - Certified export to Lean for verification  \n   - Theory morphisms that track formula mappings\n   - NOT needed for basic query evaluation (proofs are implicit in computation)\n\n2. Structure mirrors Lean Derivation.lean:\n   - Derivation : FormulaContext × Formula → Sort\n   - Constructors: axiom, var, true_intro, false_elim, conj_intro/elim, disj_intro/elim, eq_intro/elim, exists_intro/elim\n\n3. Meta-embedding options:\n   - Expand GeologMeta with Derivation sorts\n   - Separate GeologDerivation theory parameterized by GeologMeta instance\n\n4. Geometric morphisms connection:\n   - A geometric morphism T₁ → T₂ induces derivation translation\n   - Need derivations to track HOW formulas map, not just THAT they do\n\nDefer until query engine basics work.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:38:01.777111215Z","created_by":"davidad","updated_at":"2026-01-19T15:38:01.777111215Z","dependencies":[{"issue_id":"geolog-or6","depends_on_id":"geolog-7tt","type":"blocks","created_at":"2026-01-19T15:42:05.031285391Z","created_by":"davidad"}]}
{"id":"geolog-py9","title":"Solver search infrastructure","description":"Design the core search API: Goal representation (geometric sequent to witness), SearchState (partial assignments, undo trail), Tactic trait for composable search strategies. This is the foundation for the agent-driven solver davidad envisions. Key references: Knuth 4B Algorithm D, Floyd's reversible memory (Fascicle 7), Logic-Based Benders decomposition.","notes":"Updated solver.rs with corrected semantics:\n\nCRITICAL FIX: Axiom violations are OBLIGATIONS, not unsat!\n- In geometric logic, consequents are positive (∃, ∨, atomic)\n- Violation = premise satisfied, conclusion not yet witnessed\n- Obligation can ALWAYS potentially be fulfilled by refinement\n- Only CONFLICT (fulfilling would contradict existing commitment) is unsat\n\nChanges made:\n- Added Obligation type (axiom_idx, assignment, description)\n- Added AxiomCheckResult enum (AllSatisfied | Obligations)\n- Renamed PropagationTactic → CheckTactic\n- CheckTactic returns HasObligations instead of marking unsat\n- TacticResult now has HasObligations variant\n- Updated module docs explaining obligations vs conflicts\n\nThis is essentially Datalog-style forward chaining over partial models:\nobligations create pressure to add facts until fixpoint.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:35.446782775Z","updated_at":"2025-12-15T04:04:25.05768285Z","closed_at":"2025-12-15T04:04:25.05768285Z","dependencies":[{"issue_id":"geolog-py9","depends_on_id":"geolog-9k9","type":"blocks","created_at":"2025-12-15T00:48:34.514918958Z","created_by":"dev"},{"issue_id":"geolog-py9","depends_on_id":"geolog-0vd","type":"blocks","created_at":"2025-12-15T02:09:34.101961199Z","created_by":"dev"}]}
{"id":"geolog-q2x","title":"Axioms hidden in :inspect output","description":"When inspecting a theory with axioms, the axiom definitions are not shown - only a comment indicating how many axioms exist.\n\nExample:\n```\ntheory Iso {\n    X : Sort;\n    Y : Sort;\n    fwd : X -\u003e Y;\n    bwd : Y -\u003e X;\n    fb : forall x : X. |- x fwd bwd = x;\n}\n\n:inspect Iso\nOutput shows: // 1 axiom(s)\nExpected: Show the actual axiom: fb : forall x : X. |- x fwd bwd = x;\n```\n\nUsers need to see the actual axiom definitions to understand the theory's constraints.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:24.401432952Z","updated_at":"2025-12-15T00:01:37.378995078Z","closed_at":"2025-12-15T00:01:37.378995078Z"}
{"id":"geolog-qo3","title":"Forward chaining tactic","description":"Implement a tactic that automatically fulfills simple obligations: when an axiom's consequent is an existential or relation assertion, try to witness it. This is Datalog-style forward chaining. Should integrate with congruence closure for equation consequents.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:31.457694883Z","updated_at":"2025-12-15T04:06:31.457694883Z","dependencies":[{"issue_id":"geolog-qo3","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:08.941041676Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-7rn","type":"blocks","created_at":"2025-12-15T04:07:29.726008313Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:34.793149209Z","created_by":"dev"}]}
{"id":"geolog-rgg","title":"Prove Monotonic Submodel Property in Lean","design":"GeologMeta.geolog claims the Monotonic Submodel Property holds due to function/relation immutability. This should be formally verified in the Lean formalization (model-theory-topos). The property states that adding elements to a structure preserves all existing query results - crucial for incremental/concurrent evaluation. Coordinate with the existing ModelTheoryTopos/Geometric/ code.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:49.258523317Z","created_by":"davidad","updated_at":"2026-01-19T15:37:49.258523317Z"}
{"id":"geolog-ryc","title":"Higher-order application in elaboration","notes":"src/elaborate/env.rs:139 - When elaborating term application where the function position isn't a known function symbol:\n\n  // Higher-order application — not supported yet\n  Err(ElabError::UnsupportedFeature('higher-order application'))\n\nThis would be needed for first-class functions / dependent types. Low priority for geometric logic which doesn't need this.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:50.763960529Z","created_by":"davidad","updated_at":"2026-01-19T15:51:50.763960529Z"}
{"id":"geolog-ulh","title":"Product-typed function application in instance equations","design":"Instance elaboration fails when equations reference functions with product domains using record literals, e.g. `[x: a, y: b] mul = c`. Error: 'unsupported feature: complex element reference'. Need to extend elaborate/instance.rs to handle Record terms in equation LHS positions by: (1) evaluating the record to build the product-typed argument, (2) looking up or creating the function application result.","notes":"Discovered while creating examples/geolog/monoid.geolog - tried to write:\n\n```\ninstance TrivialMonoid : Monoid = {\n  u : M;\n  [unit: []] e = u;        // \u003c- fails here\n  [x: u, y: u] mul = u;    // \u003c- and here\n}\n```\n\nThe elaborator sees Record([...]) in the LHS and bails with 'unsupported feature'.\n\nRelated to function evaluation during instance elaboration - need to:\n1. Recognize when LHS is a function application with product domain\n2. Build the product-typed argument from the Record\n3. Register the function mapping","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T00:27:00.904154649Z","created_by":"davidad","updated_at":"2026-01-19T00:56:56.100838432Z","closed_at":"2026-01-19T00:56:56.100838432Z","close_reason":"Implemented product-typed function application in instance equations. Added FunctionColumn::ProductLocal variant with nested Vec storage (Binary/Ternary/General), updated instance elaboration to handle Record terms in equation LHS, updated REPL inspect command to display product domain values. Full test coverage added. monoid.geolog now works with Trivial, BoolAnd, and BoolOr instances."}
{"id":"geolog-vzh","title":"Fix Box::leak memory leak in MetaReader::new","design":"In src/meta.rs, MetaReader::new() uses Box::leak(Box::new(meta.theory.signature.clone())) to extend the lifetime of the signature. This leaks memory on every call. Should instead store Arc\u003cElaboratedTheory\u003e or use a lifetime parameter to borrow from the caller's Arc.","notes":"In src/meta.rs line ~641: sig: Box::leak(Box::new(meta.theory.signature.clone())). Should store Arc\u003cElaboratedTheory\u003e directly or use lifetime parameter.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:43.489090254Z","created_by":"davidad","updated_at":"2026-01-19T15:46:55.671253625Z","closed_at":"2026-01-19T15:46:55.671253625Z","close_reason":"Fixed: MetaReader now stores Arc\u003cElaboratedTheory\u003e instead of leaking cloned Signature"}
{"id":"geolog-w7a","title":"Duplicate instance names silently overwrite","description":"Defining an instance with a name that already exists silently replaces the old instance without any warning or error.\n\nExample:\n```\ntheory T { X : Sort; }\ninstance I1 : T = { a : X; }\ninstance I1 : T = { b : X; }  // Silently replaces the first I1\n```\n\nSame issue as with duplicate theory names - users should be warned about overwrites.\n\nLocation: src/repl.rs (execute_geolog, instance registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:58.373441794Z","updated_at":"2025-12-15T00:02:14.722840298Z","closed_at":"2025-12-15T00:02:14.722840298Z"}
{"id":"geolog-w8m","title":"Property-based testing with proptest","description":"From ROADMAP.md: Generate random ASTs, print, re-parse, compare. Some proptest infrastructure exists in tests/generators.rs but is mostly unused.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:11.022184496Z","updated_at":"2025-12-15T03:08:24.678221459Z","closed_at":"2025-12-15T03:08:24.678221459Z"}
{"id":"geolog-xj2","title":"Complete geometric logic solver","description":"Full solver implementation for instance synthesis. Builds on py9's SearchTree infrastructure. Needs congruence closure for equation handling, derivation search for unsat detection, and integration with REPL queries.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T04:05:17.492342994Z","updated_at":"2025-12-15T04:05:37.712288053Z"}
{"id":"geolog-xsr","title":"Ariadne error messages","description":"From ROADMAP.md: Pretty error reporting with source spans. The ariadne crate is already in Cargo.toml but not used yet.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:20.060918294Z","updated_at":"2025-12-15T00:49:20.060918294Z"}
{"id":"geolog-xte","title":"Parse errors are cryptic and show internal token names","description":"When a parse error occurs, the error message shows internal token representations that are not user-friendly.\n\nExample:\n```\ntheory BadSyntax {\n    X : Sort\n    Y : Sort;  // Missing semicolon after X\n}\n\nError: Parser errors: [Simple { span: 38..39, reason: Unexpected, expected: {Some(Sort), Some(LParen), Some(LBracket), Some(Instance), Some(Semicolon), Some(Slash), Some(Arrow)}, found: Some(Colon), label: None }]\n```\n\nExpected: 'Error: Expected semicolon after sort declaration on line 2, found \":\"'\n\nThe error should be human-readable and point to the specific location with line/column numbers.\n\nLocation: src/parser.rs or src/lexer.rs (error reporting using chumsky's error handling)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:45:19.886462562Z","updated_at":"2025-12-14T23:01:59.353326107Z","closed_at":"2025-12-14T23:01:59.353328107Z"}
{"id":"geolog-xw5","title":"Relations completely omitted from :inspect output","description":"When inspecting a theory that includes relations, the relations are completely omitted from the output.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:inspect WithRelation\nOutput shows only: X : Sort;\nExpected: Should also show R : [x : X, y : X] Relation;\n```\n\nRelations are a first-class part of the theory signature but are invisible in the REPL output.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:45:38.560834631Z","updated_at":"2025-12-15T00:01:46.509652398Z","closed_at":"2025-12-15T00:01:46.509652398Z"}
{"id":"geolog-yi1","title":"Parameterized instance elaboration","description":"elaborate_instance currently returns 'unsupported feature: parameterized instance types' for types like 'N Marking instance' where N is a parameter. Need to handle theory application and instantiate the parameterized signature with concrete arguments.","notes":"Progress made:\n1. Parameterized theory elaboration now copies param sorts/funcs into local signature with qualified names (N/P, N/in/src, etc.)\n2. resolve_instance_type() parses parameterized instance types like `ExampleNet Marking`\n3. Added InstanceMeta to Workspace for tracking element names\n\n**NEW (commit 38f2134): Workspace infrastructure complete**\n- Workspace.resolve_element() can resolve paths like [\"ExampleNet\", \"A\"]\n- Workspace.resolve_in_instance() for param-bound lookups\n- InstanceEntry tracks element names for each instance\n\nStill needed:\n- Wire elaborate_instance to take \u0026mut Workspace instead of (\u0026Env, \u0026mut Universe)\n- In resolve_instance_element, call workspace.resolve_element() for multi-segment paths\n- Handle external elements (Luid) in equation processing for functions with external codomains\n\nThe architecture now supports cross-instance refs naturally - the remaining work is just plumbing.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:57.147063688Z","updated_at":"2025-12-15T10:43:58.144891005Z","dependencies":[{"issue_id":"geolog-yi1","depends_on_id":"geolog-8z9","type":"related","created_at":"2025-12-15T09:42:03.47134483Z","created_by":"dev"}]}
