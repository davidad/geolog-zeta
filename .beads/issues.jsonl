{"id":"geolog-0vd","title":"Solver API design sketch","description":"Design the agent-facing API for driving search (davidad's vision).\n\nCore concepts:\n- Goal: geometric sequent to witness\n- SearchState: partial assignments, undo trail (Floyd's reversible memory)\n- Tactic trait: decompose goal into subgoals\n\nBuilt-in tactics:\n- Instantiate: pick witnesses for existentials\n- SatFill: hand off to batsat for finite completion of partial functions\n- Unfold: expand theory definitions\n- ApplyAxiom: use a theory axiom\n\nKey references:\n- Knuth 4B: Algorithm D for CSP, Dancing Cells\n- Logic-Based Benders decomposition (CDCL as special case)\n- batsat crate for Boolean satisfiability\n\nThe tensor machinery (TensorExpr, check_sequent) provides the constraint checking substrate. The solver sits on top, guiding search.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:09:09.460777853Z","updated_at":"2025-12-15T02:34:13.370291896Z","closed_at":"2025-12-15T02:34:13.370291896Z","dependencies":[{"issue_id":"geolog-0vd","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:09:28.987309673Z","created_by":"dev"}]}
{"id":"geolog-0ya","title":"Incremental axiom checking for patches","description":"When a patch adds tuples to a relation, only re-check relevant axioms.\n\nCALM insight: monotone patches + geometric logic = only need to check if new tuples made antecedent true without consequent being true.\n\nAlgorithm:\n1. Track axiom→relation dependencies (which relations appear in antecedent)\n2. On patch adding tuple (a,b,...) to relation R:\n   - Find axioms with R in antecedent\n   - For each: check substitutions involving (a,b,...)\n   - Report violations or (for derived relations) trigger forward chaining\n\nThis is semi-naive Datalog evaluation for the special case of monotone patches.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:00.766060992Z","updated_at":"2025-12-15T02:08:00.766060992Z","dependencies":[{"issue_id":"geolog-0ya","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:08:44.370614869Z","created_by":"dev"}]}
{"id":"geolog-1d4","title":"Nested instance elaboration","description":"elaborate_instance returns 'unsupported feature: nested instance' for inline instance definitions like 'initial_marking = { t : token; t token/of = A; }'. Need to recursively elaborate and properly link nested structures.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:09.300786049Z","updated_at":"2025-12-15T00:45:09.300786049Z"}
{"id":"geolog-1wv","title":"Confusing error message when referencing undefined theory","description":"When creating an instance with a non-existent theory (e.g., 'instance I : NonexistentTheory = {...}'), the error message says 'unknown sort: NonexistentTheory' instead of 'unknown theory: NonexistentTheory'. This is confusing because the user is trying to reference a theory, not a sort.\n\nExample:\n```\ninstance BadInstance : NonexistentTheory = { x : Sort; }\nError: Elaboration error: unknown sort: NonexistentTheory\n```\n\nExpected: 'Error: unknown theory: NonexistentTheory'\n\nLocation: src/elaborate.rs (type_expr_to_theory_name or instance elaboration)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:43:20.191143097Z","updated_at":"2025-12-14T23:01:50.22790128Z","closed_at":"2025-12-14T23:01:50.22790378Z"}
{"id":"geolog-386","title":"Deep AST equality for roundtrip tests","description":"From ROADMAP.md: Recursive comparison for AST roundtrip tests. Currently pretty-print tests just check that parsing succeeds, not that the AST is equivalent.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:01.210591756Z","updated_at":"2025-12-15T00:49:01.210591756Z"}
{"id":"geolog-3cc","title":"Compile core::Formula to TensorExpr","description":"Bridge from elaborated formulas to tensor evaluation.\n\nNeed to traverse core::Formula and emit TensorExpr:\n- RelF(rel_id, terms) → Leaf tensor from structure.relations[rel_id], with variable bindings from terms\n- Conj([φ, ψ, ...]) → conjunction_all() \n- Disj([φ, ψ, ...]) → need to add disjunction support (pointwise OR)\n- Exists(var, φ) → exists(φ_expr, var)\n- Eq(t1, t2) → diagonal constraint (identity tensor contracted)\n- True → scalar(true)\n- False → scalar(false)\n\nKey consideration: variable names come from the Formula's context, need to thread through consistently.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:29.320693546Z","updated_at":"2025-12-15T02:25:51.202125726Z","closed_at":"2025-12-15T02:25:51.202125726Z","dependencies":[{"issue_id":"geolog-3cc","depends_on_id":"geolog-dr6","type":"blocks","created_at":"2025-12-15T02:08:39.275188263Z","created_by":"dev"}]}
{"id":"geolog-3pa","title":"Duplicate theory names silently overwrite","description":"Defining a theory with a name that already exists silently replaces the old theory without any warning or error.\n\nExample:\n```\ntheory T1 { X : Sort; }\ntheory T1 { Y : Sort; }  // Silently replaces the first T1\n```\n\nThis can lead to confusion and unintended behavior. The REPL should either:\n1. Reject duplicate names with an error\n2. Warn the user and ask for confirmation\n3. Use a versioning/shadowing approach with clear indication\n\nLocation: src/repl.rs (execute_geolog, theory registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:43.845301347Z","updated_at":"2025-12-15T00:02:05.64745744Z","closed_at":"2025-12-15T00:02:05.64745744Z"}
{"id":"geolog-4kk","title":"Add RelationPatch to patch.rs","description":"Patch type is missing relation changes. ElementPatch and FunctionPatch exist, but relations can also be asserted/retracted. Add RelationPatch with assertions/retractions (by UUID tuples), update Patch struct, and update diff/apply_patch functions.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T03:45:40.158190009Z","updated_at":"2025-12-15T03:45:40.158190009Z"}
{"id":"geolog-4ww","title":"Relation semantics","description":"Relations exist in Signature and can be declared in theories, but there's no runtime representation in Structure. Need to add relation storage (likely RoaringTreemap for each relation's extent) and evaluation for RelF formulas.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:21.340217502Z","updated_at":"2025-12-15T01:32:54.076075002Z","closed_at":"2025-12-15T01:32:54.076075002Z"}
{"id":"geolog-5zt","title":"Query execution stub","description":"The REPL returns 'Queries not yet implemented' for query declarations. Need to design and implement the entry point for the solver API - turning a QueryDecl into a Goal that the search machinery can work on.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:23.044058015Z","updated_at":"2025-12-15T00:50:22.951103236Z","dependencies":[{"issue_id":"geolog-5zt","depends_on_id":"geolog-py9","type":"blocks","created_at":"2025-12-15T00:48:19.228400368Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-yi1","type":"blocks","created_at":"2025-12-15T00:48:24.321393995Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-1d4","type":"blocks","created_at":"2025-12-15T00:48:29.40937604Z","created_by":"dev"}]}
{"id":"geolog-7cc","title":"Product sorts (record types) hidden in :inspect","description":"When inspecting a theory with product sorts (record types), they are counted in the sort count but not displayed in the output.\n\nExample:\n```\ntheory WithProduct {\n    X : Sort;\n    Y : Sort;\n    Pair : [fst : X, snd : Y] Sort;\n}\n\n:inspect WithProduct\nOutput shows: X : Sort; Y : Sort;  (only 2 of 3 sorts shown)\nExpected: Should also show Pair : [fst : X, snd : Y] Sort;\n```\n\nThe theory shows '2 sorts' in the count but Pair is being counted somewhere and not displayed.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","design":"Add syntax for named product sorts, e.g. 'Pair : Sort = [fst : X, snd : Y];'. This would require: (1) Parser changes to support this new sort declaration syntax, (2) Elaboration logic to create a sort with product structure, (3) Pretty-printer support. Currently record types only exist as relation domains or in-line product types within function signatures.","notes":"Reclassified as feature request per investigation. Would require new parser/elaboration support for syntax like 'Pair : Sort = [fst : X, snd : Y];'. The label feature-request was already added.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:46:17.713086239Z","updated_at":"2025-12-15T00:49:55.697516521Z","labels":["feature-request","syntax"]}
{"id":"geolog-9k9","title":"Axiom checking / constraint propagation","description":"Axioms (sequents) are stored but never evaluated. Need infrastructure to: (1) check if an axiom is satisfied by a structure, (2) propagate constraints when partial assignments are made, (3) detect conflicts early. This connects to the CALM theorem insight - only need to check new potential violations from new patches.","notes":"Progress update: Implemented lazy tensor expressions (TensorExpr) with fusion.\n\nKey insight: TensorExpr builds expression tree; Contract(Product(...)) fuses into hash join without materializing Cartesian product.\n\nImplemented:\n- SparseTensor (materialized BTreeSet\u003cVec\u003cusize\u003e\u003e)\n- TensorExpr::Leaf | Product | Contract (lazy)\n- fused_join with hash join for 2-way case\n- conjunction() and exists() helpers for variable alignment\n- 7 tests passing including large sparse join\n\nNext: compile core::Formula → TensorExpr, then check_sequent","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:44.924943873Z","updated_at":"2025-12-15T02:32:54.742909783Z","closed_at":"2025-12-15T02:32:54.742909783Z","dependencies":[{"issue_id":"geolog-9k9","depends_on_id":"geolog-4ww","type":"blocks","created_at":"2025-12-15T00:48:39.614746335Z","created_by":"dev"}]}
{"id":"geolog-bpd","title":"Leapfrog Triejoin for multi-way joins","description":"Current fused_join uses hash join for 2-way, nested loops for 3+ way.\n\nLeapfrog Triejoin is worst-case optimal for multi-way joins. Requires:\n- Relations sorted by each variable order (multiple indexes)\n- 'seek' operation: given column and bound, find next value ≥ bound\n- Iterators that can 'leapfrog' to sync up across relations\n\nReferences:\n- Veldhuizen 2014: 'Leapfrog Triejoin: A Simple, Worst-Case Optimal Join Algorithm'\n- LogicBlox / RelationalAI implementations\n\nWould replace CartesianProductIter fallback in fused_join for 3+ relations.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:56.518803879Z","updated_at":"2025-12-15T02:08:56.518803879Z"}
{"id":"geolog-cbd","title":"Function signatures shown as '...' in theory inspection","description":"When using ':inspect TheoryName' to view a theory, function signatures are shown as '...' instead of their actual type signatures.\n\nExample:\n```\ntheory Graph {\n    V : Sort;\n    E : Sort;\n    src : E -\u003e V;\n    tgt : E -\u003e V;\n}\n\n:inspect Graph\nOutput shows: src : ...; tgt : ...;\nExpected: src : E -\u003e V; tgt : E -\u003e V;\n```\n\nLocation: src/repl.rs (format_theory_for_display or similar)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:43:46.702440405Z","updated_at":"2025-12-14T23:02:08.731222991Z","closed_at":"2025-12-14T23:02:08.731224449Z"}
{"id":"geolog-crk","title":"Relations not counted in :list theories summary","description":"When listing theories with ':list theories', the summary shows counts for sorts, functions, and axioms, but not relations.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:list theories\nOutput: WithRelation (1 sorts, 0 functions, 0 axioms)\nExpected: WithRelation (1 sorts, 0 functions, 1 relations, 0 axioms)\n```\n\nThis is a minor issue but makes relations feel like second-class citizens in the type system.\n\nLocation: src/repl.rs (list_theories or TheoryInfo)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:45:58.654532341Z","updated_at":"2025-12-15T00:02:23.801766158Z","closed_at":"2025-12-15T00:02:23.801766158Z"}
{"id":"geolog-d0b","title":"Parameterized theories don't show parameters in :inspect","description":"When inspecting a parameterized theory, the parameter list is not shown in the output.\n\nExample:\n```\ntheory (N : PetriNet instance) Marking {\n    token : Sort;\n}\n\n:inspect Marking\nOutput shows: theory Marking { token : Sort; }\nExpected: theory (N : PetriNet instance) Marking { token : Sort; }\n```\n\nThe parameter information is lost in the display, making it unclear that this is a parameterized theory.\n\nLocation: src/repl.rs (theory formatting)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:05.212783874Z","updated_at":"2025-12-15T00:01:55.559419526Z","closed_at":"2025-12-15T00:01:55.559419526Z"}
{"id":"geolog-dr6","title":"Disjunction support in TensorExpr","description":"Currently TensorExpr only has Product (AND). Need Disjunction (OR) for full formula support.\n\nOptions:\n1. Add TensorExpr::Sum variant (lazy union of extents)\n2. Handle at compile time by expanding? (bad for large disjunctions)\n\nSum(Vec\u003cTensorExpr\u003e) with same dimensions → union of extents.\nFusion opportunity: Contract(Sum(...)) can distribute.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:51.22924934Z","updated_at":"2025-12-15T02:21:00.378783288Z","closed_at":"2025-12-15T02:21:00.378783288Z"}
{"id":"geolog-far","title":"check_sequent implementation","description":"Given a Sequent and Structure, check if the axiom is satisfied.\n\nFor sequent '∀ctx. ante ⊢ conseq':\n1. compile ante → TensorExpr (over ctx variables)\n2. compile conseq → TensorExpr (over ctx variables)  \n3. check: every tuple in ante.materialize() is also in conseq\n\nCan short-circuit on first violation.\n\nFor geometric logic, conseq is positive (no negation), so this is straightforward subset check. Violations are tuples where ante is true but conseq is false.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:41.508562065Z","updated_at":"2025-12-15T02:31:07.980264916Z","closed_at":"2025-12-15T02:31:07.980264916Z","dependencies":[{"issue_id":"geolog-far","depends_on_id":"geolog-3cc","type":"blocks","created_at":"2025-12-15T02:08:34.180308033Z","created_by":"dev"}]}
{"id":"geolog-py9","title":"Solver search infrastructure","description":"Design the core search API: Goal representation (geometric sequent to witness), SearchState (partial assignments, undo trail), Tactic trait for composable search strategies. This is the foundation for the agent-driven solver davidad envisions. Key references: Knuth 4B Algorithm D, Floyd's reversible memory (Fascicle 7), Logic-Based Benders decomposition.","notes":"Updated solver.rs with corrected semantics:\n\nCRITICAL FIX: Axiom violations are OBLIGATIONS, not unsat!\n- In geometric logic, consequents are positive (∃, ∨, atomic)\n- Violation = premise satisfied, conclusion not yet witnessed\n- Obligation can ALWAYS potentially be fulfilled by refinement\n- Only CONFLICT (fulfilling would contradict existing commitment) is unsat\n\nChanges made:\n- Added Obligation type (axiom_idx, assignment, description)\n- Added AxiomCheckResult enum (AllSatisfied | Obligations)\n- Renamed PropagationTactic → CheckTactic\n- CheckTactic returns HasObligations instead of marking unsat\n- TacticResult now has HasObligations variant\n- Updated module docs explaining obligations vs conflicts\n\nThis is essentially Datalog-style forward chaining over partial models:\nobligations create pressure to add facts until fixpoint.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:35.446782775Z","updated_at":"2025-12-15T04:04:25.05768285Z","closed_at":"2025-12-15T04:04:25.05768285Z","dependencies":[{"issue_id":"geolog-py9","depends_on_id":"geolog-9k9","type":"blocks","created_at":"2025-12-15T00:48:34.514918958Z","created_by":"dev"},{"issue_id":"geolog-py9","depends_on_id":"geolog-0vd","type":"blocks","created_at":"2025-12-15T02:09:34.101961199Z","created_by":"dev"}]}
{"id":"geolog-q2x","title":"Axioms hidden in :inspect output","description":"When inspecting a theory with axioms, the axiom definitions are not shown - only a comment indicating how many axioms exist.\n\nExample:\n```\ntheory Iso {\n    X : Sort;\n    Y : Sort;\n    fwd : X -\u003e Y;\n    bwd : Y -\u003e X;\n    fb : forall x : X. |- x fwd bwd = x;\n}\n\n:inspect Iso\nOutput shows: // 1 axiom(s)\nExpected: Show the actual axiom: fb : forall x : X. |- x fwd bwd = x;\n```\n\nUsers need to see the actual axiom definitions to understand the theory's constraints.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:24.401432952Z","updated_at":"2025-12-15T00:01:37.378995078Z","closed_at":"2025-12-15T00:01:37.378995078Z"}
{"id":"geolog-w7a","title":"Duplicate instance names silently overwrite","description":"Defining an instance with a name that already exists silently replaces the old instance without any warning or error.\n\nExample:\n```\ntheory T { X : Sort; }\ninstance I1 : T = { a : X; }\ninstance I1 : T = { b : X; }  // Silently replaces the first I1\n```\n\nSame issue as with duplicate theory names - users should be warned about overwrites.\n\nLocation: src/repl.rs (execute_geolog, instance registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:58.373441794Z","updated_at":"2025-12-15T00:02:14.722840298Z","closed_at":"2025-12-15T00:02:14.722840298Z"}
{"id":"geolog-w8m","title":"Property-based testing with proptest","description":"From ROADMAP.md: Generate random ASTs, print, re-parse, compare. Some proptest infrastructure exists in tests/generators.rs but is mostly unused.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:11.022184496Z","updated_at":"2025-12-15T03:08:24.678221459Z","closed_at":"2025-12-15T03:08:24.678221459Z"}
{"id":"geolog-xsr","title":"Ariadne error messages","description":"From ROADMAP.md: Pretty error reporting with source spans. The ariadne crate is already in Cargo.toml but not used yet.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:20.060918294Z","updated_at":"2025-12-15T00:49:20.060918294Z"}
{"id":"geolog-xte","title":"Parse errors are cryptic and show internal token names","description":"When a parse error occurs, the error message shows internal token representations that are not user-friendly.\n\nExample:\n```\ntheory BadSyntax {\n    X : Sort\n    Y : Sort;  // Missing semicolon after X\n}\n\nError: Parser errors: [Simple { span: 38..39, reason: Unexpected, expected: {Some(Sort), Some(LParen), Some(LBracket), Some(Instance), Some(Semicolon), Some(Slash), Some(Arrow)}, found: Some(Colon), label: None }]\n```\n\nExpected: 'Error: Expected semicolon after sort declaration on line 2, found \":\"'\n\nThe error should be human-readable and point to the specific location with line/column numbers.\n\nLocation: src/parser.rs or src/lexer.rs (error reporting using chumsky's error handling)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:45:19.886462562Z","updated_at":"2025-12-14T23:01:59.353326107Z","closed_at":"2025-12-14T23:01:59.353328107Z"}
{"id":"geolog-xw5","title":"Relations completely omitted from :inspect output","description":"When inspecting a theory that includes relations, the relations are completely omitted from the output.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:inspect WithRelation\nOutput shows only: X : Sort;\nExpected: Should also show R : [x : X, y : X] Relation;\n```\n\nRelations are a first-class part of the theory signature but are invisible in the REPL output.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:45:38.560834631Z","updated_at":"2025-12-15T00:01:46.509652398Z","closed_at":"2025-12-15T00:01:46.509652398Z"}
{"id":"geolog-yi1","title":"Parameterized instance elaboration","description":"elaborate_instance currently returns 'unsupported feature: parameterized instance types' for types like 'N Marking instance' where N is a parameter. Need to handle theory application and instantiate the parameterized signature with concrete arguments.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:57.147063688Z","updated_at":"2025-12-15T00:44:57.147063688Z"}
