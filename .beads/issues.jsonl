{"id":"geolog-0vd","title":"Solver API design sketch","description":"Design the agent-facing API for driving search (davidad's vision).\n\nCore concepts:\n- Goal: geometric sequent to witness\n- SearchState: partial assignments, undo trail (Floyd's reversible memory)\n- Tactic trait: decompose goal into subgoals\n\nBuilt-in tactics:\n- Instantiate: pick witnesses for existentials\n- SatFill: hand off to batsat for finite completion of partial functions\n- Unfold: expand theory definitions\n- ApplyAxiom: use a theory axiom\n\nKey references:\n- Knuth 4B: Algorithm D for CSP, Dancing Cells\n- Logic-Based Benders decomposition (CDCL as special case)\n- batsat crate for Boolean satisfiability\n\nThe tensor machinery (TensorExpr, check_sequent) provides the constraint checking substrate. The solver sits on top, guiding search.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:09:09.460777853Z","updated_at":"2025-12-15T02:34:13.370291896Z","closed_at":"2025-12-15T02:34:13.370291896Z","dependencies":[{"issue_id":"geolog-0vd","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:09:28.987309673Z","created_by":"dev"}]}
{"id":"geolog-0ya","title":"Incremental axiom checking for patches","description":"When a patch adds tuples to a relation, only re-check relevant axioms.\n\nCALM insight: monotone patches + geometric logic = only need to check if new tuples made antecedent true without consequent being true.\n\nAlgorithm:\n1. Track axiom→relation dependencies (which relations appear in antecedent)\n2. On patch adding tuple (a,b,...) to relation R:\n   - Find axioms with R in antecedent\n   - For each: check substitutions involving (a,b,...)\n   - Report violations or (for derived relations) trigger forward chaining\n\nThis is semi-naive Datalog evaluation for the special case of monotone patches.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:00.766060992Z","updated_at":"2025-12-15T02:08:00.766060992Z","dependencies":[{"issue_id":"geolog-0ya","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:08:44.370614869Z","created_by":"dev"}]}
{"id":"geolog-1d4","title":"Nested instance elaboration","description":"elaborate_instance returns 'unsupported feature: nested instance' for inline instance definitions like 'initial_marking = { t : token; t token/of = A; }'. Need to recursively elaborate and properly link nested structures.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:09.300786049Z","updated_at":"2025-12-15T00:45:09.300786049Z"}
{"id":"geolog-1wv","title":"Confusing error message when referencing undefined theory","description":"When creating an instance with a non-existent theory (e.g., 'instance I : NonexistentTheory = {...}'), the error message says 'unknown sort: NonexistentTheory' instead of 'unknown theory: NonexistentTheory'. This is confusing because the user is trying to reference a theory, not a sort.\n\nExample:\n```\ninstance BadInstance : NonexistentTheory = { x : Sort; }\nError: Elaboration error: unknown sort: NonexistentTheory\n```\n\nExpected: 'Error: unknown theory: NonexistentTheory'\n\nLocation: src/elaborate.rs (type_expr_to_theory_name or instance elaboration)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:43:20.191143097Z","updated_at":"2025-12-14T23:01:50.22790128Z","closed_at":"2025-12-14T23:01:50.22790378Z"}
{"id":"geolog-386","title":"Deep AST equality for roundtrip tests","description":"From ROADMAP.md: Recursive comparison for AST roundtrip tests. Currently pretty-print tests just check that parsing succeeds, not that the AST is equivalent.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:01.210591756Z","updated_at":"2025-12-15T00:49:01.210591756Z"}
{"id":"geolog-3cc","title":"Compile core::Formula to TensorExpr","description":"Bridge from elaborated formulas to tensor evaluation.\n\nNeed to traverse core::Formula and emit TensorExpr:\n- RelF(rel_id, terms) → Leaf tensor from structure.relations[rel_id], with variable bindings from terms\n- Conj([φ, ψ, ...]) → conjunction_all() \n- Disj([φ, ψ, ...]) → need to add disjunction support (pointwise OR)\n- Exists(var, φ) → exists(φ_expr, var)\n- Eq(t1, t2) → diagonal constraint (identity tensor contracted)\n- True → scalar(true)\n- False → scalar(false)\n\nKey consideration: variable names come from the Formula's context, need to thread through consistently.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:29.320693546Z","updated_at":"2025-12-15T02:25:51.202125726Z","closed_at":"2025-12-15T02:25:51.202125726Z","dependencies":[{"issue_id":"geolog-3cc","depends_on_id":"geolog-dr6","type":"blocks","created_at":"2025-12-15T02:08:39.275188263Z","created_by":"dev"}]}
{"id":"geolog-3pa","title":"Duplicate theory names silently overwrite","description":"Defining a theory with a name that already exists silently replaces the old theory without any warning or error.\n\nExample:\n```\ntheory T1 { X : Sort; }\ntheory T1 { Y : Sort; }  // Silently replaces the first T1\n```\n\nThis can lead to confusion and unintended behavior. The REPL should either:\n1. Reject duplicate names with an error\n2. Warn the user and ask for confirmation\n3. Use a versioning/shadowing approach with clear indication\n\nLocation: src/repl.rs (execute_geolog, theory registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:43.845301347Z","updated_at":"2025-12-15T00:02:05.64745744Z","closed_at":"2025-12-15T00:02:05.64745744Z"}
{"id":"geolog-4kk","title":"Add RelationPatch to patch.rs","description":"Patch type is missing relation changes. ElementPatch and FunctionPatch exist, but relations can also be asserted/retracted. Add RelationPatch with assertions/retractions (by UUID tuples), update Patch struct, and update diff/apply_patch functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T03:45:40.158190009Z","updated_at":"2026-01-19T01:56:39.44419015Z","closed_at":"2026-01-19T01:56:39.44419015Z","close_reason":"Added RelationPatch struct with assertions/retractions, updated Patch struct with num_relations field, implemented relation diffing and application in diff() and apply_patch(), with full inversion support."}
{"id":"geolog-4ww","title":"Relation semantics","description":"Relations exist in Signature and can be declared in theories, but there's no runtime representation in Structure. Need to add relation storage (likely RoaringTreemap for each relation's extent) and evaluation for RelF formulas.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:21.340217502Z","updated_at":"2025-12-15T01:32:54.076075002Z","closed_at":"2025-12-15T01:32:54.076075002Z"}
{"id":"geolog-5zt","title":"Query execution stub","description":"The REPL returns 'Queries not yet implemented' for query declarations. Need to design and implement the entry point for the solver API - turning a QueryDecl into a Goal that the search machinery can work on.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:23.044058015Z","updated_at":"2025-12-15T00:50:22.951103236Z","dependencies":[{"issue_id":"geolog-5zt","depends_on_id":"geolog-py9","type":"blocks","created_at":"2025-12-15T00:48:19.228400368Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-yi1","type":"blocks","created_at":"2025-12-15T00:48:24.321393995Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-1d4","type":"blocks","created_at":"2025-12-15T00:48:29.40937604Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-xj2","type":"blocks","created_at":"2025-12-15T04:07:56.271359664Z","created_by":"dev"}]}
{"id":"geolog-7cc","title":"Product sorts (record types) hidden in :inspect","description":"When inspecting a theory with product sorts (record types), they are counted in the sort count but not displayed in the output.\n\nExample:\n```\ntheory WithProduct {\n    X : Sort;\n    Y : Sort;\n    Pair : [fst : X, snd : Y] Sort;\n}\n\n:inspect WithProduct\nOutput shows: X : Sort; Y : Sort;  (only 2 of 3 sorts shown)\nExpected: Should also show Pair : [fst : X, snd : Y] Sort;\n```\n\nThe theory shows '2 sorts' in the count but Pair is being counted somewhere and not displayed.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","design":"Add syntax for named product sorts, e.g. 'Pair : Sort = [fst : X, snd : Y];'. This would require: (1) Parser changes to support this new sort declaration syntax, (2) Elaboration logic to create a sort with product structure, (3) Pretty-printer support. Currently record types only exist as relation domains or in-line product types within function signatures.","notes":"Reclassified as feature request per investigation. Would require new parser/elaboration support for syntax like 'Pair : Sort = [fst : X, snd : Y];'. The label feature-request was already added.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:46:17.713086239Z","updated_at":"2025-12-15T00:49:55.697516521Z","labels":["feature-request","syntax"]}
{"id":"geolog-7rn","title":"Pending equations tracking in solver","description":"Add PendingEquation type to solver. When CheckTactic finds an equation consequent, or when function values conflict, create a pending equation instead of treating as error. Equations feed into congruence closure.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:18.765134027Z","updated_at":"2026-01-19T01:52:24.44555405Z","closed_at":"2026-01-19T01:52:24.44555405Z","close_reason":"PendingEquation type added to solver/types.rs with lhs/rhs Slid fields and EquationReason enum (FunctionConflict, AxiomConsequent, UserAsserted, Congruence). Integrated with CongruenceClosure which manages a VecDeque\u003cPendingEquation\u003e.","dependencies":[{"issue_id":"geolog-7rn","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:03.840723585Z","created_by":"dev"}]}
{"id":"geolog-8z9","title":"State management and naming refactoring","description":"Consolidate REPL's Env and Workspace into a single source of truth, and overhaul NamingIndex with reverse-path BTreeMap for efficient suffix-based lookup.\n\nSee: loose_thoughts/2025-12-15_09:40_state_and_naming_refactor.md","design":"Radical simplification: eliminate ElaboratedTheory (almost entirely).\n\nBootstrap sequence:\n1. Parse GeologMeta.geolog → AST\n2. Elaborate → ElaboratedTheory (ONLY use of this type)\n3. Convert via theory_to_structure() → primordial GeologMeta instance\n4. From then on, everything is Structure queries\n\nKey components:\n- Workspace holds: Universe, NamingIndex (with reverse-path BTreeMap), GeologMeta Structure, user instances\n- ElaboratedTheory/Signature/Theory become bootstrap-only types\n- NamingIndex maps ALL UUIDs (theories, sorts, funcs, instances, elements) via reversed paths\n- Cross-instance refs like \"ExampleNet/A\" become BTreeMap suffix lookups\n\nMigration phases:\n1. NamingIndex: add ReversedPath BTreeMap\n2. Workspace: hold GeologMeta Structure instead of HashMap\u003cString, Rc\u003cElaboratedTheory\u003e\u003e\n3. Elaboration: emit directly to GeologMeta Structure (not ElaboratedTheory)\n4. ReplState: thin wrapper around Workspace\n5. Cross-instance references via NamingIndex","notes":"Phase 1 COMPLETE (commit d5c57a3): NamingIndex with ReversedPath BTreeMap\n\nPhase 2 COMPLETE (commit 38f2134): Unified Workspace\n- Workspace owns: universe, naming, meta, instances, theories\n- InstanceEntry holds structure + element name mappings\n- ReplState is thin wrapper around Workspace\n- resolve_element() provides unified name resolution for cross-instance refs\n- resolve_in_instance() for param-qualified lookups\n\nNext: Wire elaborate_instance to use Workspace.resolve_element() for cross-instance references. Then yi1 is fully solved and we can close it.\n\nRemaining from original design:\n- Phase 3: elaborate_theory to mutate workspace.meta directly (not ElaboratedTheory)\n- Phase 4: full ElaboratedTheory elimination (bootstrap-only)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-15T09:41:48.891488701Z","updated_at":"2025-12-15T10:43:53.00811471Z"}
{"id":"geolog-9k9","title":"Axiom checking / constraint propagation","description":"Axioms (sequents) are stored but never evaluated. Need infrastructure to: (1) check if an axiom is satisfied by a structure, (2) propagate constraints when partial assignments are made, (3) detect conflicts early. This connects to the CALM theorem insight - only need to check new potential violations from new patches.","notes":"Progress update: Implemented lazy tensor expressions (TensorExpr) with fusion.\n\nKey insight: TensorExpr builds expression tree; Contract(Product(...)) fuses into hash join without materializing Cartesian product.\n\nImplemented:\n- SparseTensor (materialized BTreeSet\u003cVec\u003cusize\u003e\u003e)\n- TensorExpr::Leaf | Product | Contract (lazy)\n- fused_join with hash join for 2-way case\n- conjunction() and exists() helpers for variable alignment\n- 7 tests passing including large sparse join\n\nNext: compile core::Formula → TensorExpr, then check_sequent","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:44.924943873Z","updated_at":"2025-12-15T02:32:54.742909783Z","closed_at":"2025-12-15T02:32:54.742909783Z","dependencies":[{"issue_id":"geolog-9k9","depends_on_id":"geolog-4ww","type":"blocks","created_at":"2025-12-15T00:48:39.614746335Z","created_by":"dev"}]}
{"id":"geolog-bpd","title":"Leapfrog Triejoin for multi-way joins","description":"Current fused_join uses hash join for 2-way, nested loops for 3+ way.\n\nLeapfrog Triejoin is worst-case optimal for multi-way joins. Requires:\n- Relations sorted by each variable order (multiple indexes)\n- 'seek' operation: given column and bound, find next value ≥ bound\n- Iterators that can 'leapfrog' to sync up across relations\n\nReferences:\n- Veldhuizen 2014: 'Leapfrog Triejoin: A Simple, Worst-Case Optimal Join Algorithm'\n- LogicBlox / RelationalAI implementations\n\nWould replace CartesianProductIter fallback in fused_join for 3+ relations.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:56.518803879Z","updated_at":"2025-12-15T02:08:56.518803879Z"}
{"id":"geolog-cbd","title":"Function signatures shown as '...' in theory inspection","description":"When using ':inspect TheoryName' to view a theory, function signatures are shown as '...' instead of their actual type signatures.\n\nExample:\n```\ntheory Graph {\n    V : Sort;\n    E : Sort;\n    src : E -\u003e V;\n    tgt : E -\u003e V;\n}\n\n:inspect Graph\nOutput shows: src : ...; tgt : ...;\nExpected: src : E -\u003e V; tgt : E -\u003e V;\n```\n\nLocation: src/repl.rs (format_theory_for_display or similar)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:43:46.702440405Z","updated_at":"2025-12-14T23:02:08.731222991Z","closed_at":"2025-12-14T23:02:08.731224449Z"}
{"id":"geolog-crk","title":"Relations not counted in :list theories summary","description":"When listing theories with ':list theories', the summary shows counts for sorts, functions, and axioms, but not relations.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:list theories\nOutput: WithRelation (1 sorts, 0 functions, 0 axioms)\nExpected: WithRelation (1 sorts, 0 functions, 1 relations, 0 axioms)\n```\n\nThis is a minor issue but makes relations feel like second-class citizens in the type system.\n\nLocation: src/repl.rs (list_theories or TheoryInfo)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:45:58.654532341Z","updated_at":"2025-12-15T00:02:23.801766158Z","closed_at":"2025-12-15T00:02:23.801766158Z"}
{"id":"geolog-d0b","title":"Parameterized theories don't show parameters in :inspect","description":"When inspecting a parameterized theory, the parameter list is not shown in the output.\n\nExample:\n```\ntheory (N : PetriNet instance) Marking {\n    token : Sort;\n}\n\n:inspect Marking\nOutput shows: theory Marking { token : Sort; }\nExpected: theory (N : PetriNet instance) Marking { token : Sort; }\n```\n\nThe parameter information is lost in the display, making it unclear that this is a parameterized theory.\n\nLocation: src/repl.rs (theory formatting)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:05.212783874Z","updated_at":"2025-12-15T00:01:55.559419526Z","closed_at":"2025-12-15T00:01:55.559419526Z"}
{"id":"geolog-dkk","title":"Derivation search for False","description":"Implement search for derivations of ⊢ False from instantiated axioms. When pending equations are merged, check if any axiom with False as consequent has its premise satisfied. This is the only way to detect true unsatisfiability in geometric logic. See Derivation.lean in model-theory-topos for reference.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:09.104194054Z","updated_at":"2025-12-15T04:06:09.104194054Z","dependencies":[{"issue_id":"geolog-dkk","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:58.72989683Z","created_by":"dev"},{"issue_id":"geolog-dkk","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:24.662048457Z","created_by":"dev"}]}
{"id":"geolog-dr6","title":"Disjunction support in TensorExpr","description":"Currently TensorExpr only has Product (AND). Need Disjunction (OR) for full formula support.\n\nOptions:\n1. Add TensorExpr::Sum variant (lazy union of extents)\n2. Handle at compile time by expanding? (bad for large disjunctions)\n\nSum(Vec\u003cTensorExpr\u003e) with same dimensions → union of extents.\nFusion opportunity: Contract(Sum(...)) can distribute.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:51.22924934Z","updated_at":"2025-12-15T02:21:00.378783288Z","closed_at":"2025-12-15T02:21:00.378783288Z"}
{"id":"geolog-far","title":"check_sequent implementation","description":"Given a Sequent and Structure, check if the axiom is satisfied.\n\nFor sequent '∀ctx. ante ⊢ conseq':\n1. compile ante → TensorExpr (over ctx variables)\n2. compile conseq → TensorExpr (over ctx variables)  \n3. check: every tuple in ante.materialize() is also in conseq\n\nCan short-circuit on first violation.\n\nFor geometric logic, conseq is positive (no negation), so this is straightforward subset check. Violations are tuples where ante is true but conseq is false.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:41.508562065Z","updated_at":"2025-12-15T02:31:07.980264916Z","closed_at":"2025-12-15T02:31:07.980264916Z","dependencies":[{"issue_id":"geolog-far","depends_on_id":"geolog-3cc","type":"blocks","created_at":"2025-12-15T02:08:34.180308033Z","created_by":"dev"}]}
{"id":"geolog-fjy","title":"Congruence closure for equation handling","description":"Implement union-find with path compression for tracking element equivalences. When equations are created (from function conflicts or axiom consequents), merge equivalence classes and propagate through function applications. This is the EUF (equality + uninterpreted functions) core.","notes":"Added CongruenceClosure to SearchNode with union-find, pending equation queue, merge/find/are_equal methods. Tests passing. Next: propagation through functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:05:46.937966821Z","updated_at":"2026-01-19T01:51:38.871919901Z","closed_at":"2026-01-19T01:51:38.871919901Z","close_reason":"Implemented CongruenceClosure struct with union-find, PendingEquation queue, and integration with SearchNode in solver/types.rs","dependencies":[{"issue_id":"geolog-fjy","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:53.635588612Z","created_by":"dev"}]}
{"id":"geolog-py9","title":"Solver search infrastructure","description":"Design the core search API: Goal representation (geometric sequent to witness), SearchState (partial assignments, undo trail), Tactic trait for composable search strategies. This is the foundation for the agent-driven solver davidad envisions. Key references: Knuth 4B Algorithm D, Floyd's reversible memory (Fascicle 7), Logic-Based Benders decomposition.","notes":"Updated solver.rs with corrected semantics:\n\nCRITICAL FIX: Axiom violations are OBLIGATIONS, not unsat!\n- In geometric logic, consequents are positive (∃, ∨, atomic)\n- Violation = premise satisfied, conclusion not yet witnessed\n- Obligation can ALWAYS potentially be fulfilled by refinement\n- Only CONFLICT (fulfilling would contradict existing commitment) is unsat\n\nChanges made:\n- Added Obligation type (axiom_idx, assignment, description)\n- Added AxiomCheckResult enum (AllSatisfied | Obligations)\n- Renamed PropagationTactic → CheckTactic\n- CheckTactic returns HasObligations instead of marking unsat\n- TacticResult now has HasObligations variant\n- Updated module docs explaining obligations vs conflicts\n\nThis is essentially Datalog-style forward chaining over partial models:\nobligations create pressure to add facts until fixpoint.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:35.446782775Z","updated_at":"2025-12-15T04:04:25.05768285Z","closed_at":"2025-12-15T04:04:25.05768285Z","dependencies":[{"issue_id":"geolog-py9","depends_on_id":"geolog-9k9","type":"blocks","created_at":"2025-12-15T00:48:34.514918958Z","created_by":"dev"},{"issue_id":"geolog-py9","depends_on_id":"geolog-0vd","type":"blocks","created_at":"2025-12-15T02:09:34.101961199Z","created_by":"dev"}]}
{"id":"geolog-q2x","title":"Axioms hidden in :inspect output","description":"When inspecting a theory with axioms, the axiom definitions are not shown - only a comment indicating how many axioms exist.\n\nExample:\n```\ntheory Iso {\n    X : Sort;\n    Y : Sort;\n    fwd : X -\u003e Y;\n    bwd : Y -\u003e X;\n    fb : forall x : X. |- x fwd bwd = x;\n}\n\n:inspect Iso\nOutput shows: // 1 axiom(s)\nExpected: Show the actual axiom: fb : forall x : X. |- x fwd bwd = x;\n```\n\nUsers need to see the actual axiom definitions to understand the theory's constraints.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:24.401432952Z","updated_at":"2025-12-15T00:01:37.378995078Z","closed_at":"2025-12-15T00:01:37.378995078Z"}
{"id":"geolog-qo3","title":"Forward chaining tactic","description":"Implement a tactic that automatically fulfills simple obligations: when an axiom's consequent is an existential or relation assertion, try to witness it. This is Datalog-style forward chaining. Should integrate with congruence closure for equation consequents.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:31.457694883Z","updated_at":"2025-12-15T04:06:31.457694883Z","dependencies":[{"issue_id":"geolog-qo3","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:08.941041676Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-7rn","type":"blocks","created_at":"2025-12-15T04:07:29.726008313Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:34.793149209Z","created_by":"dev"}]}
{"id":"geolog-ulh","title":"Product-typed function application in instance equations","design":"Instance elaboration fails when equations reference functions with product domains using record literals, e.g. `[x: a, y: b] mul = c`. Error: 'unsupported feature: complex element reference'. Need to extend elaborate/instance.rs to handle Record terms in equation LHS positions by: (1) evaluating the record to build the product-typed argument, (2) looking up or creating the function application result.","notes":"Discovered while creating examples/geolog/monoid.geolog - tried to write:\n\n```\ninstance TrivialMonoid : Monoid = {\n  u : M;\n  [unit: []] e = u;        // \u003c- fails here\n  [x: u, y: u] mul = u;    // \u003c- and here\n}\n```\n\nThe elaborator sees Record([...]) in the LHS and bails with 'unsupported feature'.\n\nRelated to function evaluation during instance elaboration - need to:\n1. Recognize when LHS is a function application with product domain\n2. Build the product-typed argument from the Record\n3. Register the function mapping","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T00:27:00.904154649Z","created_by":"davidad","updated_at":"2026-01-19T00:56:56.100838432Z","closed_at":"2026-01-19T00:56:56.100838432Z","close_reason":"Implemented product-typed function application in instance equations. Added FunctionColumn::ProductLocal variant with nested Vec storage (Binary/Ternary/General), updated instance elaboration to handle Record terms in equation LHS, updated REPL inspect command to display product domain values. Full test coverage added. monoid.geolog now works with Trivial, BoolAnd, and BoolOr instances."}
{"id":"geolog-w7a","title":"Duplicate instance names silently overwrite","description":"Defining an instance with a name that already exists silently replaces the old instance without any warning or error.\n\nExample:\n```\ntheory T { X : Sort; }\ninstance I1 : T = { a : X; }\ninstance I1 : T = { b : X; }  // Silently replaces the first I1\n```\n\nSame issue as with duplicate theory names - users should be warned about overwrites.\n\nLocation: src/repl.rs (execute_geolog, instance registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:58.373441794Z","updated_at":"2025-12-15T00:02:14.722840298Z","closed_at":"2025-12-15T00:02:14.722840298Z"}
{"id":"geolog-w8m","title":"Property-based testing with proptest","description":"From ROADMAP.md: Generate random ASTs, print, re-parse, compare. Some proptest infrastructure exists in tests/generators.rs but is mostly unused.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:11.022184496Z","updated_at":"2025-12-15T03:08:24.678221459Z","closed_at":"2025-12-15T03:08:24.678221459Z"}
{"id":"geolog-xj2","title":"Complete geometric logic solver","description":"Full solver implementation for instance synthesis. Builds on py9's SearchTree infrastructure. Needs congruence closure for equation handling, derivation search for unsat detection, and integration with REPL queries.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T04:05:17.492342994Z","updated_at":"2025-12-15T04:05:37.712288053Z"}
{"id":"geolog-xsr","title":"Ariadne error messages","description":"From ROADMAP.md: Pretty error reporting with source spans. The ariadne crate is already in Cargo.toml but not used yet.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:20.060918294Z","updated_at":"2025-12-15T00:49:20.060918294Z"}
{"id":"geolog-xte","title":"Parse errors are cryptic and show internal token names","description":"When a parse error occurs, the error message shows internal token representations that are not user-friendly.\n\nExample:\n```\ntheory BadSyntax {\n    X : Sort\n    Y : Sort;  // Missing semicolon after X\n}\n\nError: Parser errors: [Simple { span: 38..39, reason: Unexpected, expected: {Some(Sort), Some(LParen), Some(LBracket), Some(Instance), Some(Semicolon), Some(Slash), Some(Arrow)}, found: Some(Colon), label: None }]\n```\n\nExpected: 'Error: Expected semicolon after sort declaration on line 2, found \":\"'\n\nThe error should be human-readable and point to the specific location with line/column numbers.\n\nLocation: src/parser.rs or src/lexer.rs (error reporting using chumsky's error handling)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:45:19.886462562Z","updated_at":"2025-12-14T23:01:59.353326107Z","closed_at":"2025-12-14T23:01:59.353328107Z"}
{"id":"geolog-xw5","title":"Relations completely omitted from :inspect output","description":"When inspecting a theory that includes relations, the relations are completely omitted from the output.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:inspect WithRelation\nOutput shows only: X : Sort;\nExpected: Should also show R : [x : X, y : X] Relation;\n```\n\nRelations are a first-class part of the theory signature but are invisible in the REPL output.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:45:38.560834631Z","updated_at":"2025-12-15T00:01:46.509652398Z","closed_at":"2025-12-15T00:01:46.509652398Z"}
{"id":"geolog-yi1","title":"Parameterized instance elaboration","description":"elaborate_instance currently returns 'unsupported feature: parameterized instance types' for types like 'N Marking instance' where N is a parameter. Need to handle theory application and instantiate the parameterized signature with concrete arguments.","notes":"Progress made:\n1. Parameterized theory elaboration now copies param sorts/funcs into local signature with qualified names (N/P, N/in/src, etc.)\n2. resolve_instance_type() parses parameterized instance types like `ExampleNet Marking`\n3. Added InstanceMeta to Workspace for tracking element names\n\n**NEW (commit 38f2134): Workspace infrastructure complete**\n- Workspace.resolve_element() can resolve paths like [\"ExampleNet\", \"A\"]\n- Workspace.resolve_in_instance() for param-bound lookups\n- InstanceEntry tracks element names for each instance\n\nStill needed:\n- Wire elaborate_instance to take \u0026mut Workspace instead of (\u0026Env, \u0026mut Universe)\n- In resolve_instance_element, call workspace.resolve_element() for multi-segment paths\n- Handle external elements (Luid) in equation processing for functions with external codomains\n\nThe architecture now supports cross-instance refs naturally - the remaining work is just plumbing.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:57.147063688Z","updated_at":"2025-12-15T10:43:58.144891005Z","dependencies":[{"issue_id":"geolog-yi1","depends_on_id":"geolog-8z9","type":"related","created_at":"2025-12-15T09:42:03.47134483Z","created_by":"dev"}]}
