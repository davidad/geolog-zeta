{"id":"geolog-0jh","title":"Full axiom reconstruction in structure_to_theory","notes":"src/meta.rs:828 - structure_to_theory() returns empty axioms vec with 'TODO: Full axiom reconstruction'.\n\nNeed to walk the GeologMeta structure to reconstruct Sequent → Formula → Term AST. Required for loading saved theories.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:34.449414106Z","created_by":"davidad","updated_at":"2026-01-20T00:47:56.944693419Z","closed_at":"2026-01-20T00:47:56.944693419Z","close_reason":"Implemented axiom reconstruction in structure_to_theory - commit 3cf0af7"}
{"id":"geolog-0vd","title":"Solver API design sketch","description":"Design the agent-facing API for driving search (davidad's vision).\n\nCore concepts:\n- Goal: geometric sequent to witness\n- SearchState: partial assignments, undo trail (Floyd's reversible memory)\n- Tactic trait: decompose goal into subgoals\n\nBuilt-in tactics:\n- Instantiate: pick witnesses for existentials\n- SatFill: hand off to batsat for finite completion of partial functions\n- Unfold: expand theory definitions\n- ApplyAxiom: use a theory axiom\n\nKey references:\n- Knuth 4B: Algorithm D for CSP, Dancing Cells\n- Logic-Based Benders decomposition (CDCL as special case)\n- batsat crate for Boolean satisfiability\n\nThe tensor machinery (TensorExpr, check_sequent) provides the constraint checking substrate. The solver sits on top, guiding search.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:09:09.460777853Z","updated_at":"2025-12-15T02:34:13.370291896Z","closed_at":"2025-12-15T02:34:13.370291896Z","dependencies":[{"issue_id":"geolog-0vd","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:09:28.987309673Z","created_by":"dev"}]}
{"id":"geolog-0ya","title":"Incremental axiom checking for patches","description":"When a patch adds tuples to a relation, only re-check relevant axioms.\n\nCALM insight: monotone patches + geometric logic = only need to check if new tuples made antecedent true without consequent being true.\n\nAlgorithm:\n1. Track axiom→relation dependencies (which relations appear in antecedent)\n2. On patch adding tuple (a,b,...) to relation R:\n   - Find axioms with R in antecedent\n   - For each: check substitutions involving (a,b,...)\n   - Report violations or (for derived relations) trigger forward chaining\n\nThis is semi-naive Datalog evaluation for the special case of monotone patches.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:00.766060992Z","updated_at":"2025-12-15T02:08:00.766060992Z","dependencies":[{"issue_id":"geolog-0ya","depends_on_id":"geolog-far","type":"blocks","created_at":"2025-12-15T02:08:44.370614869Z","created_by":"dev"}]}
{"id":"geolog-1d4","title":"Nested instance elaboration","description":"elaborate_instance returns 'unsupported feature: nested instance' for inline instance definitions like 'initial_marking = { t : token; t token/of = A; }'. Need to recursively elaborate and properly link nested structures.","notes":"## Update 2026-01-20: Significant Progress\n\nNested instance elaboration is now **partially working**:\n- Basic nested instances like `trace = { f1 : F; ... }` elaborate correctly\n- Elements get proper sorts and can reference parent instance elements\n- Nested structures are tracked in `Structure.nested` HashMap\n\n**Still needed:**\n- Cross-instance references (see geolog-47a)\n- Record literal values in function assignments (see geolog-a85)\n\n## Implementation Analysis (2026-01-20)\n\n### Current State\nThe parser does parse nested instances:\n- `name = { ... }` syntax creates `InstanceItem::NestedInstance`\n- Theory is marked as `_inferred` since it's not explicitly specified\n- Elaboration returns `UnsupportedFeature(\"nested instance: {name}\")`\n\n### Required Implementation Steps\n\n1. **Type Resolution**\n   - Look up the parent instance's theory\n   - Find what sort/type the nested field should have\n   - The field should be declared in the parent theory (e.g., `initial_marking : N Marking instance`)\n\n2. **Recursive Elaboration**\n   - Once the type is known, recursively call `elaborate_instance_ctx`\n   - The nested instance gets its own `Structure`\n   - Need to handle cross-references between parent and nested elements\n\n3. **Structure Linking**\n   - The nested instance's Structure needs to be linked to the parent\n   - Elements in the nested instance might reference parent elements\n   - Parent elements might reference nested instance elements\n\n4. **Key Questions**\n   - Should the nested Structure be embedded in the parent, or separate?\n   - How do we handle references across the boundary?\n   - What about deeply nested instances (nesting of nesting)?\n\n### Example Use Case\n```geolog\ntheory PetriNet { P : Sort; T : Sort; ... }\ntheory (N : PetriNet instance) Marking { token : Sort; token/of : token -\u003e N/P; }\n\ninstance MyNet : PetriNet = {\n  a : P;\n  b : P;\n  initial_marking = { t1 : token; t1 token/of = a; }  // nested instance\n}\n```\n\nThe nested `initial_marking` instance:\n- Is of type `MyNet Marking` (parameterized by the parent instance)\n- Can reference `a` from the parent via `t1 token/of = a`\n- Needs its own elements (`t1`) elaborated into its own carrier\n\n### Blocking\nThis blocks geolog-5zt (query execution) because query witnesses may need to create nested structures.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:09.300786049Z","updated_at":"2026-01-20T14:45:32.936618488Z"}
{"id":"geolog-1fn","title":"Instance-typed field declarations and access","notes":"Original design has instance-typed field declarations: 'initial_marking : N Marking instance;' and field access: 'trace input_terminal' (access sort from instance), 'RP initial_marking token' (access field, then sort). Currently parses as plain Sort but loses instance/theory connection. Need proper elaboration and access semantics.","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:42:30.13181445Z","created_by":"davidad","updated_at":"2026-01-20T11:42:39.302329396Z","closed_at":"2026-01-20T11:42:39.302329396Z","close_reason":"Implemented instance-typed field access: theories can now declare and access nested instance fields with proper sort resolution and parameter substitution. Test: 'iso : RP/initial/Token RP/target/Token Iso instance;' works correctly."}
{"id":"geolog-1wv","title":"Confusing error message when referencing undefined theory","description":"When creating an instance with a non-existent theory (e.g., 'instance I : NonexistentTheory = {...}'), the error message says 'unknown sort: NonexistentTheory' instead of 'unknown theory: NonexistentTheory'. This is confusing because the user is trying to reference a theory, not a sort.\n\nExample:\n```\ninstance BadInstance : NonexistentTheory = { x : Sort; }\nError: Elaboration error: unknown sort: NonexistentTheory\n```\n\nExpected: 'Error: unknown theory: NonexistentTheory'\n\nLocation: src/elaborate.rs (type_expr_to_theory_name or instance elaboration)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:43:20.191143097Z","updated_at":"2025-12-14T23:01:50.22790128Z","closed_at":"2025-12-14T23:01:50.22790378Z"}
{"id":"geolog-2ir","title":"Unified copy-on-write structure loading","design":"Always load MappedStructure (immutable zero-copy base). Mutations create a WorkingStructure that holds patches/deltas on top of the base. Reads check patch layer first, fall back to base. Commit materializes patches into new immutable structure. This unifies the loading story and naturally supports undo/rollback.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T13:50:55.60169436Z","created_by":"davidad","updated_at":"2026-01-19T14:21:14.615027243Z","closed_at":"2026-01-19T14:21:14.615027243Z","close_reason":"Implemented OverlayStructure in src/overlay.rs - patch-on-write system that always loads MappedStructure as immutable base, accumulates mutations in StructureDelta, reads check delta first then fall back to base, commit materializes to new MappedStructure. Includes 9 proptests in tests/proptest_overlay.rs verifying overlay reads match committed structure."}
{"id":"geolog-32x","title":"Implement RelAlgIR theory and compiler","design":"See loose_thoughts/2026-01-19_19:45_relalg_ir_design.md\n\nRelAlgIR is a geolog theory whose instances ARE query plans (string diagrams).\n\nKey insight: Wires are first-class. Composition is wire-sharing.\n\nSub-tasks:\n1. Write RelAlgIR.geolog theory file\n2. Compiler: theory-extension queries → RelAlgIR instances\n3. CPU backend functor (Vec\u003cSlid\u003e, hash joins, etc.)\n4. Optimization axioms (filter pushdown, etc.)\n5. DBSP operators for incremental evaluation\n6. GPU backend (longer term)\n\nThis replaces the ad-hoc Pattern-based query engine with principled string diagram IR.","notes":"2026-01-20 07:45: Session complete! RelAlgIR compiler has 11/13 operators implemented (missing Constant, Apply). RelAlgIR interpreter (CPU backend) is complete. Full roundtrip test passing: QueryOp → compile → execute → verify results. All 7 predicate types working. 45 commits total this morning. Remaining: Constant/Apply operators, schema propagation, streaming execution for DBSP operators.","status":"in_progress","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T22:14:24.316315204Z","created_by":"davidad","updated_at":"2026-01-20T07:44:07.158962937Z"}
{"id":"geolog-386","title":"Deep AST equality for roundtrip tests","description":"From ROADMAP.md: Recursive comparison for AST roundtrip tests. Currently pretty-print tests just check that parsing succeeds, not that the AST is equivalent.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:01.210591756Z","updated_at":"2025-12-15T00:49:01.210591756Z"}
{"id":"geolog-3cc","title":"Compile core::Formula to TensorExpr","description":"Bridge from elaborated formulas to tensor evaluation.\n\nNeed to traverse core::Formula and emit TensorExpr:\n- RelF(rel_id, terms) → Leaf tensor from structure.relations[rel_id], with variable bindings from terms\n- Conj([φ, ψ, ...]) → conjunction_all() \n- Disj([φ, ψ, ...]) → need to add disjunction support (pointwise OR)\n- Exists(var, φ) → exists(φ_expr, var)\n- Eq(t1, t2) → diagonal constraint (identity tensor contracted)\n- True → scalar(true)\n- False → scalar(false)\n\nKey consideration: variable names come from the Formula's context, need to thread through consistently.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:29.320693546Z","updated_at":"2025-12-15T02:25:51.202125726Z","closed_at":"2025-12-15T02:25:51.202125726Z","dependencies":[{"issue_id":"geolog-3cc","depends_on_id":"geolog-dr6","type":"blocks","created_at":"2025-12-15T02:08:39.275188263Z","created_by":"dev"}]}
{"id":"geolog-3pa","title":"Duplicate theory names silently overwrite","description":"Defining a theory with a name that already exists silently replaces the old theory without any warning or error.\n\nExample:\n```\ntheory T1 { X : Sort; }\ntheory T1 { Y : Sort; }  // Silently replaces the first T1\n```\n\nThis can lead to confusion and unintended behavior. The REPL should either:\n1. Reject duplicate names with an error\n2. Warn the user and ask for confirmation\n3. Use a versioning/shadowing approach with clear indication\n\nLocation: src/repl.rs (execute_geolog, theory registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:43.845301347Z","updated_at":"2025-12-15T00:02:05.64745744Z","closed_at":"2025-12-15T00:02:05.64745744Z"}
{"id":"geolog-47a","title":"Cross-references between sibling nested instances","notes":"When elaborating an instance with multiple nested instances, elements from one nested instance cannot be referenced by another:\n\n```geolog\ninstance solution0 : ExampleNet problem0 Solution = {\n  trace = { it : input_terminal; ... };\n  initial_iso = { \n    it fwd = problem0/initial_marking/tok;  // ERROR: unknown variable \"it\"\n  };\n}\n```\n\nThe `it` element is in the `trace` nested instance but needs to be accessible in `initial_iso`.\n\nSolution: Use Luid-based lookup across sibling nested structures. Elements should be findable via qualified path (e.g., `trace/it`) that resolves to the Luid in the trace nested structure.\n\nThis is a natural extension of geolog-1d4 (nested instance elaboration) but specifically about cross-instance element resolution.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T14:45:04.975097286Z","created_by":"davidad","updated_at":"2026-01-20T14:45:04.975097286Z","dependencies":[{"issue_id":"geolog-47a","depends_on_id":"geolog-1d4","type":"related","created_at":"2026-01-20T14:45:15.575618865Z","created_by":"davidad"}]}
{"id":"geolog-4kk","title":"Add RelationPatch to patch.rs","description":"Patch type is missing relation changes. ElementPatch and FunctionPatch exist, but relations can also be asserted/retracted. Add RelationPatch with assertions/retractions (by UUID tuples), update Patch struct, and update diff/apply_patch functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T03:45:40.158190009Z","updated_at":"2026-01-19T01:56:39.44419015Z","closed_at":"2026-01-19T01:56:39.44419015Z","close_reason":"Added RelationPatch struct with assertions/retractions, updated Patch struct with num_relations field, implemented relation diffing and application in diff() and apply_patch(), with full inversion support."}
{"id":"geolog-4ww","title":"Relation semantics","description":"Relations exist in Signature and can be declared in theories, but there's no runtime representation in Structure. Need to add relation storage (likely RoaringTreemap for each relation's extent) and evaluation for RelF formulas.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:45:21.340217502Z","updated_at":"2025-12-15T01:32:54.076075002Z","closed_at":"2025-12-15T01:32:54.076075002Z"}
{"id":"geolog-5zt","title":"Query execution stub","description":"The REPL returns 'Queries not yet implemented' for query declarations. Need to design and implement the entry point for the solver API - turning a QueryDecl into a Goal that the search machinery can work on.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:23.044058015Z","updated_at":"2025-12-15T00:50:22.951103236Z","dependencies":[{"issue_id":"geolog-5zt","depends_on_id":"geolog-py9","type":"blocks","created_at":"2025-12-15T00:48:19.228400368Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-yi1","type":"blocks","created_at":"2025-12-15T00:48:24.321393995Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-1d4","type":"blocks","created_at":"2025-12-15T00:48:29.40937604Z","created_by":"dev"},{"issue_id":"geolog-5zt","depends_on_id":"geolog-xj2","type":"blocks","created_at":"2025-12-15T04:07:56.271359664Z","created_by":"dev"}]}
{"id":"geolog-69b","title":"Handle disjunctions with different free variables in tensor builder","notes":"## Problem\n\nThe tensor builder panics when compiling disjunctions where the two disjuncts\nhave different free variables. Example from todo_list.geolog:\n\n```\nax/dep_blocked : forall x : Item, y : Item.\n  [x: x, y: y] depends_on |- [item: x] blocked \\/ [item: y] completed;\n```\n\nThe conclusion `blocked(x) \\/ completed(y)` has {x} in left disjunct and {y}\nin right disjunct.\n\n## Location\n\nsrc/tensor/builder.rs:117-126 - `union_tensors` function\n\n## Proposed Fix\n\nInstead of panicking, extend each tensor with the missing variables by taking\na product with the full domain for those variables. This treats the missing\nvariable as \"any value\", which is the correct semantics.\n\nE.g., `blocked(x) \\/ completed(y)` should become:\n- blocked(x) × Item^y (tensor with both x and y)\n- completed(y) × Item^x (tensor with both x and y)\nThen union them.\n\n## Related\n\nThis is valid geometric logic - disjunctions don't require same free variables.\nThe tensor representation just needs to be extended.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T03:40:55.812694552Z","created_by":"davidad","updated_at":"2026-01-20T03:47:42.158703946Z","closed_at":"2026-01-20T03:47:42.158703946Z","close_reason":"Fixed: compile_formula now extends disjuncts with missing variables using full-domain tensors"}
{"id":"geolog-6r5","title":"Implement theory extension (extends keyword)","design":"The parser now supports 'theory Foo extends Bar { ... }' syntax, but the elaborator ignores the extends clause. Need to:\n1. Look up parent theory in elaboration context\n2. Import all sorts, functions, relations, and axioms from parent\n3. Make them available in child theory scope\n4. Handle transitive extension (A extends B extends C)\n5. Add tests for extension semantics\n\nCurrently RelAlgIR works around this by defining Srt/Func/Elem locally.","notes":"## 2026-01-20 COMPLETED\n\n### Commits\n- 88cd14e: Support qualified sort names in instance elaboration\n- 626f09e: Implement transitive extends with requalification semantics\n\n### What Works\n- Single-level extends: `theory Child extends Base`\n- Transitive extends: `theory Child extends Parent extends Grandparent`\n- Requalification: grandparent types keep original qualifiers\n- Instance creation for extended theories\n\n### Remaining (future work)\n- Axiom inheritance (needs ID remapping)","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T22:28:31.456989181Z","created_by":"davidad","updated_at":"2026-01-20T01:24:01.088008569Z","closed_at":"2026-01-20T01:24:01.088010486Z"}
{"id":"geolog-7cc","title":"Product sorts (record types) hidden in :inspect","description":"When inspecting a theory with product sorts (record types), they are counted in the sort count but not displayed in the output.\n\nExample:\n```\ntheory WithProduct {\n    X : Sort;\n    Y : Sort;\n    Pair : [fst : X, snd : Y] Sort;\n}\n\n:inspect WithProduct\nOutput shows: X : Sort; Y : Sort;  (only 2 of 3 sorts shown)\nExpected: Should also show Pair : [fst : X, snd : Y] Sort;\n```\n\nThe theory shows '2 sorts' in the count but Pair is being counted somewhere and not displayed.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","design":"Add syntax for named product sorts, e.g. 'Pair : Sort = [fst : X, snd : Y];'. This would require: (1) Parser changes to support this new sort declaration syntax, (2) Elaboration logic to create a sort with product structure, (3) Pretty-printer support. Currently record types only exist as relation domains or in-line product types within function signatures.","notes":"Reclassified as feature request per investigation. Would require new parser/elaboration support for syntax like 'Pair : Sort = [fst : X, snd : Y];'. The label feature-request was already added.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:46:17.713086239Z","updated_at":"2025-12-15T00:49:55.697516521Z","labels":["feature-request","syntax"]}
{"id":"geolog-7f1","title":"Wire Store to REPL and deprecate workspace.rs","notes":"The Store architecture (src/store/) implements GeologMeta-as-source-of-truth with append-only, patch-based versioning. But it's not wired up to the rest of the system yet.\n\nMigration needed:\n1. Wire REPL (src/repl.rs) to use Store instead of workspace\n2. Wire bin/geolog.rs commands (:commit, :add, :assert, :retract, :history) to Store\n3. Update elaborate/instance.rs to use Store\n4. Update overlay.rs to work with Store\n5. Eventually deprecate/remove workspace.rs\n\nFiles still using workspace.rs:\n- src/repl.rs\n- src/bin/geolog.rs  \n- src/elaborate/instance.rs\n- src/overlay.rs\n- src/zerocopy.rs","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:50:50.19462555Z","created_by":"davidad","updated_at":"2026-01-19T16:07:41.206771994Z","closed_at":"2026-01-19T16:07:41.206771994Z","close_reason":"Store is now wired to the REPL. ReplState uses Store as source of truth with transitional theories/instances HashMaps for elaboration. Commands :commit, :history, :add, :assert, :retract all work. Workspace.rs deprecated. All tests pass."}
{"id":"geolog-7p5","title":"Eliminate ElaboratedTheory from codebase","description":"Phase 2 of the GeologMeta-as-source-of-truth migration. Currently we persist theories to GeologMeta and reconstruct ElaboratedTheory on load. The goal is to eliminate ElaboratedTheory entirely by refactoring elaboration to query Store directly. This will make GeologMeta the true single source of truth.","notes":"2026-01-19: Instance persistence and reconstruction now working. ElaboratedTheory is being used as a cache, with GeologMeta as the source of truth. Theories are persisted via persist_signature() and reconstructed via reconstruct_theory(). Instances are persisted via persist_instance_data() and reconstructed via reconstruct_instance(). Eliminating ElaboratedTheory entirely requires the query engine (geolog-ubi) to be in place first, so this can query Signature data directly from Store. Current architecture is correct - just needs refactoring when query engine is ready.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T16:35:43.371813677Z","created_by":"davidad","updated_at":"2026-01-19T17:22:10.153492363Z","dependencies":[{"issue_id":"geolog-7p5","depends_on_id":"geolog-ubi","type":"parent-child","created_at":"2026-01-19T16:35:55.587126307Z","created_by":"davidad"}]}
{"id":"geolog-7rn","title":"Pending equations tracking in solver","description":"Add PendingEquation type to solver. When CheckTactic finds an equation consequent, or when function values conflict, create a pending equation instead of treating as error. Equations feed into congruence closure.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:18.765134027Z","updated_at":"2026-01-19T01:52:24.44555405Z","closed_at":"2026-01-19T01:52:24.44555405Z","close_reason":"PendingEquation type added to solver/types.rs with lhs/rhs Slid fields and EquationReason enum (FunctionConflict, AxiomConsequent, UserAsserted, Congruence). Integrated with CongruenceClosure which manages a VecDeque\u003cPendingEquation\u003e.","dependencies":[{"issue_id":"geolog-7rn","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:03.840723585Z","created_by":"dev"}]}
{"id":"geolog-7tt","title":"Query engine with chase algorithm","design":"See loose_thoughts/2026-01-19_18:15_query_semantics.md (v2) for full design.\n\n**Core insight**: Queries are theory extensions. The result is the set of **MAXIMAL ELEMENTS** in the posetal reflection of well-formed Ext_M(T').\n\n**Closed sorts** (have constants): well-formedness requires exactly those constants exist. Maximal elements = one per valid witness assignment. Enumerate all witnesses.\n\n**Open sorts** (no constants, universally quantified): bounded by constraint. Posetal reflection identifies observationally-equivalent duplicates. Unique maximal element = cofree model.\n\nImplementation phases:\n1. Closed sort enumeration (constraint satisfaction)\n2. Open sort computation (relational algebra)  \n3. Chase for derived relations (semi-naive fixpoint)\n4. Mixed queries (combine both)\n\nThis replaces bootstrap_queries.rs with principled semantics.","notes":"2026-01-20 07:45: Session complete! Chase algorithm fully working with proper equi-join handling for shared variables. Reflexivity and transitivity axioms work correctly. :chase REPL command added. 8 unit tests + 2 proptests passing. Comprehensive documentation added. Discovered geolog-j0p (relation assertions in instances) was already implemented. Fixed :assert command for theory-scoped relations (geolog-p1s). 45 commits total this morning session. Remaining: existential quantification in conclusions, disjunction in premises, DBSP integration.","status":"in_progress","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:55.387812869Z","created_by":"davidad","updated_at":"2026-01-20T07:43:55.682013211Z","dependencies":[{"issue_id":"geolog-7tt","depends_on_id":"geolog-32x","type":"discovered-from","created_at":"2026-01-19T22:14:45.2207858Z","created_by":"davidad"}]}
{"id":"geolog-8sc","title":"Update stale comment on Formula::Rel","notes":"src/core.rs line 329 says 'Relation (currently unused — geometric logic often encodes via equations)' but Formula::Rel is heavily used in meta.rs, tensor/check.rs, tensor/compile.rs, repl.rs, elaborate/env.rs. Just delete the misleading comment.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:36.463055681Z","created_by":"davidad","updated_at":"2026-01-19T15:45:38.476185074Z","closed_at":"2026-01-19T15:45:38.476185074Z","close_reason":"Fixed stale comment in core.rs:328"}
{"id":"geolog-8z9","title":"State management and naming refactoring","description":"Consolidate REPL's Env and Workspace into a single source of truth, and overhaul NamingIndex with reverse-path BTreeMap for efficient suffix-based lookup.\n\nSee: loose_thoughts/2025-12-15_09:40_state_and_naming_refactor.md","design":"Radical simplification: eliminate ElaboratedTheory (almost entirely).\n\nBootstrap sequence:\n1. Parse GeologMeta.geolog → AST\n2. Elaborate → ElaboratedTheory (ONLY use of this type)\n3. Convert via theory_to_structure() → primordial GeologMeta instance\n4. From then on, everything is Structure queries\n\nKey components:\n- Workspace holds: Universe, NamingIndex (with reverse-path BTreeMap), GeologMeta Structure, user instances\n- ElaboratedTheory/Signature/Theory become bootstrap-only types\n- NamingIndex maps ALL UUIDs (theories, sorts, funcs, instances, elements) via reversed paths\n- Cross-instance refs like \"ExampleNet/A\" become BTreeMap suffix lookups\n\nMigration phases:\n1. NamingIndex: add ReversedPath BTreeMap\n2. Workspace: hold GeologMeta Structure instead of HashMap\u003cString, Rc\u003cElaboratedTheory\u003e\u003e\n3. Elaboration: emit directly to GeologMeta Structure (not ElaboratedTheory)\n4. ReplState: thin wrapper around Workspace\n5. Cross-instance references via NamingIndex","notes":"Phase 1 COMPLETE (commit d5c57a3): NamingIndex with ReversedPath BTreeMap\n\nPhase 2 COMPLETE (commit 38f2134): Unified Workspace\n- Workspace owns: universe, naming, meta, instances, theories\n- InstanceEntry holds structure + element name mappings\n- ReplState is thin wrapper around Workspace\n- resolve_element() provides unified name resolution for cross-instance refs\n- resolve_in_instance() for param-qualified lookups\n\nNext: Wire elaborate_instance to use Workspace.resolve_element() for cross-instance references. Then yi1 is fully solved and we can close it.\n\nRemaining from original design:\n- Phase 3: elaborate_theory to mutate workspace.meta directly (not ElaboratedTheory)\n- Phase 4: full ElaboratedTheory elimination (bootstrap-only)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-15T09:41:48.891488701Z","updated_at":"2026-01-19T15:50:37.349092545Z","closed_at":"2026-01-19T15:50:37.349092545Z","close_reason":"Superseded by store/ module architecture. The Store struct in src/store/mod.rs implements the vision of this epic (GeologMeta as single source of truth, append-only, patch-based versioning). New epic needed to wire Store to REPL and deprecate workspace.rs."}
{"id":"geolog-9k9","title":"Axiom checking / constraint propagation","description":"Axioms (sequents) are stored but never evaluated. Need infrastructure to: (1) check if an axiom is satisfied by a structure, (2) propagate constraints when partial assignments are made, (3) detect conflicts early. This connects to the CALM theorem insight - only need to check new potential violations from new patches.","notes":"Progress update: Implemented lazy tensor expressions (TensorExpr) with fusion.\n\nKey insight: TensorExpr builds expression tree; Contract(Product(...)) fuses into hash join without materializing Cartesian product.\n\nImplemented:\n- SparseTensor (materialized BTreeSet\u003cVec\u003cusize\u003e\u003e)\n- TensorExpr::Leaf | Product | Contract (lazy)\n- fused_join with hash join for 2-way case\n- conjunction() and exists() helpers for variable alignment\n- 7 tests passing including large sparse join\n\nNext: compile core::Formula → TensorExpr, then check_sequent","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:44.924943873Z","updated_at":"2025-12-15T02:32:54.742909783Z","closed_at":"2025-12-15T02:32:54.742909783Z","dependencies":[{"issue_id":"geolog-9k9","depends_on_id":"geolog-4ww","type":"blocks","created_at":"2025-12-15T00:48:39.614746335Z","created_by":"dev"}]}
{"id":"geolog-a85","title":"Support record literals in instance function values","notes":"Instance elaboration currently fails when trying to assign record literals to function values:\n\n```\nit input_terminal/tgt = [firing: f1, arc: ExampleNet/ab_in];\n```\n\nError: \"unsupported feature: complex element reference: Record([...])\"\n\nThe AST is parsing correctly - elaboration just needs to handle Record(...) in element references, constructing the product value from the component Slids.\n\nNeeded for full Petri Net Trace theory support.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T14:44:41.4767234Z","created_by":"davidad","updated_at":"2026-01-20T16:08:55.889982471Z","closed_at":"2026-01-20T16:08:55.889982471Z","close_reason":"Implemented product codomain support: functions can now have product codomains with record literal assignments like 'elem func = [field1: v1, field2: v2]'. Added FunctionColumn::ProductCodomain variant, init_functions_complete(), define_function_product_codomain() methods. Instance elaboration detects product codomains and parses Record RHS. Display and serialization support included. Test files demonstrate working Trace theory with product codomain wire endpoints."}
{"id":"geolog-als","title":"Disjunction in chase conclusions (branching)","notes":"Original design has axioms with disjunctive conclusions: |- A \\/ B. Chase must handle branching/non-determinism. Options: (1) enumerate all branches, (2) use skolemization, (3) track disjunctive facts. Theory parses but chase doesn't handle disjunctions in ChaseHead.","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:41:36.130083229Z","created_by":"davidad","updated_at":"2026-01-20T10:03:56.484795255Z","closed_at":"2026-01-20T10:03:56.484795255Z","close_reason":"Implemented naive/parallel chase for disjunctions - adds all disjuncts"}
{"id":"geolog-bng","title":"Implement Store::load properly","notes":"src/store/mod.rs:229 - Store::load() just creates a new empty store:\n\n  pub fn load(path: \u0026Path) -\u003e Result\u003cSelf, String\u003e {\n      // TODO: Implement proper loading\n      Ok(Self::with_path(path))\n  }\n\nShould deserialize the persisted GeologMeta structure, universe, naming index, and reconstruct head/uncommitted state.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:42.641061417Z","created_by":"davidad","updated_at":"2026-01-19T16:35:32.740489316Z","closed_at":"2026-01-19T16:35:32.740489316Z","close_reason":"Implemented Store::load, persist_signature, and reconstruct_theory. Theories now fully persist to GeologMeta and are reconstructed on load. Can create instances of persisted theories after restart.","dependencies":[{"issue_id":"geolog-bng","depends_on_id":"geolog-7f1","type":"parent-child","created_at":"2026-01-19T15:52:02.732907266Z","created_by":"davidad"}]}
{"id":"geolog-bpd","title":"Leapfrog Triejoin for multi-way joins","description":"Current fused_join uses hash join for 2-way, nested loops for 3+ way.\n\nLeapfrog Triejoin is worst-case optimal for multi-way joins. Requires:\n- Relations sorted by each variable order (multiple indexes)\n- 'seek' operation: given column and bound, find next value ≥ bound\n- Iterators that can 'leapfrog' to sync up across relations\n\nReferences:\n- Veldhuizen 2014: 'Leapfrog Triejoin: A Simple, Worst-Case Optimal Join Algorithm'\n- LogicBlox / RelationalAI implementations\n\nWould replace CartesianProductIter fallback in fused_join for 3+ relations.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T02:08:56.518803879Z","updated_at":"2025-12-15T02:08:56.518803879Z"}
{"id":"geolog-c49","title":"Chase variable binding: equi-join on shared variables","notes":"Current chase implementation uses Cross join for all conjunctions in the premise. For axioms like transitivity where variables are shared across formulas, we need equi-join conditions.\n\nExample:\n  ax/trans : forall x, y, z. [x:x, y:y] leq, [x:y, y:z] leq |- [x:x, y:z] leq\n\nCurrent behavior: Cross-joins the two leq scans (3x3=9 for 3 elements)\nExpected: Equi-join on the shared y variable (yields 3 tuples for reflexive pairs)\n\nFix requires:\n1. ScanRelation needs to know which columns map to which context variables\n2. Conjunction compilation needs to detect shared variables between formulas\n3. Use JoinCond::Equi with appropriate column indices for the join\n\nThis is the key bug preventing proper chase on transitivity axioms.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T07:15:58.049620179Z","created_by":"davidad","updated_at":"2026-01-20T07:18:35.285987566Z","closed_at":"2026-01-20T07:18:35.285987566Z","close_reason":"Fixed: added column mapping tracking and equi-join filters for shared variables in compile_premise_with_mapping()"}
{"id":"geolog-cbd","title":"Function signatures shown as '...' in theory inspection","description":"When using ':inspect TheoryName' to view a theory, function signatures are shown as '...' instead of their actual type signatures.\n\nExample:\n```\ntheory Graph {\n    V : Sort;\n    E : Sort;\n    src : E -\u003e V;\n    tgt : E -\u003e V;\n}\n\n:inspect Graph\nOutput shows: src : ...; tgt : ...;\nExpected: src : E -\u003e V; tgt : E -\u003e V;\n```\n\nLocation: src/repl.rs (format_theory_for_display or similar)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:43:46.702440405Z","updated_at":"2025-12-14T23:02:08.731222991Z","closed_at":"2025-12-14T23:02:08.731224449Z"}
{"id":"geolog-crk","title":"Relations not counted in :list theories summary","description":"When listing theories with ':list theories', the summary shows counts for sorts, functions, and axioms, but not relations.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:list theories\nOutput: WithRelation (1 sorts, 0 functions, 0 axioms)\nExpected: WithRelation (1 sorts, 0 functions, 1 relations, 0 axioms)\n```\n\nThis is a minor issue but makes relations feel like second-class citizens in the type system.\n\nLocation: src/repl.rs (list_theories or TheoryInfo)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-14T22:45:58.654532341Z","updated_at":"2025-12-15T00:02:23.801766158Z","closed_at":"2025-12-15T00:02:23.801766158Z"}
{"id":"geolog-d0b","title":"Parameterized theories don't show parameters in :inspect","description":"When inspecting a parameterized theory, the parameter list is not shown in the output.\n\nExample:\n```\ntheory (N : PetriNet instance) Marking {\n    token : Sort;\n}\n\n:inspect Marking\nOutput shows: theory Marking { token : Sort; }\nExpected: theory (N : PetriNet instance) Marking { token : Sort; }\n```\n\nThe parameter information is lost in the display, making it unclear that this is a parameterized theory.\n\nLocation: src/repl.rs (theory formatting)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:05.212783874Z","updated_at":"2025-12-15T00:01:55.559419526Z","closed_at":"2025-12-15T00:01:55.559419526Z"}
{"id":"geolog-dk9","title":"Spurious \"No declarations found\" error on blank lines","notes":"When loading files or piping input, blank lines between declarations trigger \"Error: No declarations found\". This is a minor UX issue - the declarations still process correctly, but the error message is confusing.\n\nLikely in execute_geolog() or the REPL input handling. Empty lines should be silently skipped rather than triggering an error.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T14:44:29.513300572Z","created_by":"davidad","updated_at":"2026-01-20T15:40:28.817196506Z","closed_at":"2026-01-20T15:40:28.817196506Z","close_reason":"Fixed: execute_geolog was returning only the first result. Now returns all declarations."}
{"id":"geolog-dkk","title":"Derivation search for False","description":"Implement search for derivations of ⊢ False from instantiated axioms. When pending equations are merged, check if any axiom with False as consequent has its premise satisfied. This is the only way to detect true unsatisfiability in geometric logic. See Derivation.lean in model-theory-topos for reference.","notes":"## Partially Implemented in ForwardChainingTactic (2026-01-20)\n\nThe derivation search for False is now integrated into ForwardChainingTactic:\n- When an axiom with False as consequent has its premise satisfied\n- The tactic detects this and marks the node as Unsat\n- Creates a ConflictClause recording which axiom derived False\n\nThis covers the basic case. More sophisticated derivation tracking\n(e.g., recording the full proof term, conflict-driven clause learning)\ncan be added later.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:09.104194054Z","updated_at":"2026-01-20T03:22:18.225594462Z","closed_at":"2026-01-20T03:22:18.225594462Z","close_reason":"Basic derivation search for False implemented in ForwardChainingTactic. When axiom with False consequent has premise satisfied, node is marked Unsat with ConflictClause. Full proof term tracking deferred.","dependencies":[{"issue_id":"geolog-dkk","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:58.72989683Z","created_by":"dev"},{"issue_id":"geolog-dkk","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:24.662048457Z","created_by":"dev"}]}
{"id":"geolog-dr6","title":"Disjunction support in TensorExpr","description":"Currently TensorExpr only has Product (AND). Need Disjunction (OR) for full formula support.\n\nOptions:\n1. Add TensorExpr::Sum variant (lazy union of extents)\n2. Handle at compile time by expanding? (bad for large disjunctions)\n\nSum(Vec\u003cTensorExpr\u003e) with same dimensions → union of extents.\nFusion opportunity: Contract(Sum(...)) can distribute.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:51.22924934Z","updated_at":"2025-12-15T02:21:00.378783288Z","closed_at":"2025-12-15T02:21:00.378783288Z"}
{"id":"geolog-dxr","title":"Tensor compiler panics on function application terms in equality","design":"## Problem\n\nThe tensor-based axiom checker in `src/tensor/compile.rs` panics on `Formula::Eq` when terms are not both simple variables:\n\n```rust\n// compile.rs:368-371\n_ =\u003e {\n    panic!(\"Complex term equality not yet supported\");\n}\n```\n\nThis means axioms like `forall e. |- exists v. e src = v` (asserting every edge has a source) cannot be checked via the tensor machinery.\n\n## Workaround\n\nThe forward chaining tactic (`ForwardChainingTactic`) handles function application equalities correctly via `eval_term_to_slid`, which evaluates terms in a concrete structure. The limitation is only in the tensor-based axiom checking.\n\n## Fix\n\nExtend `compile_formula` to handle:\n1. `Term::App(func, arg) = Term::Var(name, sort)` - function result equals variable\n2. `Term::Var(name, sort) = Term::App(func, arg)` - symmetric case\n3. `Term::App(...) = Term::App(...)` - function results equal\n\nThis requires building a tensor that captures: for each (arg, result) in the function extent, project to the appropriate variables.","notes":"## Workaround Implemented (2026-01-20)\n\nCommit e2cb07c adds a graceful fallback:\n\n1. `check_theory_axioms` now uses `catch_unwind` to catch panics\n2. Axioms that panic during tensor compilation are treated as 'satisfied'\n3. Panic output is suppressed with a temporary panic hook\n\nThis allows theories with function axioms (like Monoid) to find trivial models (empty structures). The unsupported axioms are handled by forward chaining via `eval_term_to_slid` when elements are added.\n\n### Proper Fix Still Needed\n\nThe tensor compiler should be extended to handle:\n- `Term::App(func, arg) = Term::Var(name, sort)`\n- `Term::Var(name, sort) = Term::App(func, arg)`\n- `Term::App(...) = Term::App(...)`\n\nThis requires building tensors that capture function extents.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T04:26:05.660893809Z","created_by":"davidad","updated_at":"2026-01-20T04:48:08.205378406Z","closed_at":"2026-01-20T04:48:08.205378406Z","close_reason":"Done: Extended tensor compiler to handle f(x)=y, y=f(x), and f(x)=g(y) patterns. Commit 87084cd."}
{"id":"geolog-e24","title":"Petri Net Reachability showcase example for README","notes":"Add the original Petri net reachability example from loose_thoughts/2025-12-12_12:10.md to the top of README.md as the flagship showcase. This demonstrates geolog's full power: parameterized theories, nested instances, existential/disjunctive axioms, and query solving. Must work end-to-end in REPL.","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:42:53.358553613Z","created_by":"davidad","updated_at":"2026-01-20T10:07:10.865318755Z","closed_at":"2026-01-20T10:07:10.865318755Z","close_reason":"Added Petri net reachability showcase to README with chase algorithm demonstration","dependencies":[{"issue_id":"geolog-e24","depends_on_id":"geolog-qw8","type":"blocks","created_at":"2026-01-20T09:43:12.088687373Z","created_by":"davidad"},{"issue_id":"geolog-e24","depends_on_id":"geolog-vqz","type":"blocks","created_at":"2026-01-20T09:43:17.232927426Z","created_by":"davidad"},{"issue_id":"geolog-e24","depends_on_id":"geolog-als","type":"blocks","created_at":"2026-01-20T09:43:22.385083604Z","created_by":"davidad"}]}
{"id":"geolog-ef2","title":"Handle schema changes in patch diffing","notes":"src/patch.rs:283 - When diffing structures, if a function exists in new but not old (schema change), we skip it. Should properly handle schema evolution in patches.\n\nContext: 'continue; // TODO: handle schema changes'","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:18.343416955Z","created_by":"davidad","updated_at":"2026-01-20T01:37:55.0814644Z","closed_at":"2026-01-20T01:37:55.0814644Z","close_reason":"Implemented schema change handling for new functions in patches"}
{"id":"geolog-far","title":"check_sequent implementation","description":"Given a Sequent and Structure, check if the axiom is satisfied.\n\nFor sequent '∀ctx. ante ⊢ conseq':\n1. compile ante → TensorExpr (over ctx variables)\n2. compile conseq → TensorExpr (over ctx variables)  \n3. check: every tuple in ante.materialize() is also in conseq\n\nCan short-circuit on first violation.\n\nFor geometric logic, conseq is positive (no negation), so this is straightforward subset check. Violations are tuples where ante is true but conseq is false.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T02:07:41.508562065Z","updated_at":"2025-12-15T02:31:07.980264916Z","closed_at":"2025-12-15T02:31:07.980264916Z","dependencies":[{"issue_id":"geolog-far","depends_on_id":"geolog-3cc","type":"blocks","created_at":"2025-12-15T02:08:34.180308033Z","created_by":"dev"}]}
{"id":"geolog-fjy","title":"Congruence closure for equation handling","description":"Implement union-find with path compression for tracking element equivalences. When equations are created (from function conflicts or axiom consequents), merge equivalence classes and propagate through function applications. This is the EUF (equality + uninterpreted functions) core.","notes":"Added CongruenceClosure to SearchNode with union-find, pending equation queue, merge/find/are_equal methods. Tests passing. Next: propagation through functions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:05:46.937966821Z","updated_at":"2026-01-19T01:51:38.871919901Z","closed_at":"2026-01-19T01:51:38.871919901Z","close_reason":"Implemented CongruenceClosure struct with union-find, PendingEquation queue, and integration with SearchNode in solver/types.rs","dependencies":[{"issue_id":"geolog-fjy","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:06:53.635588612Z","created_by":"dev"}]}
{"id":"geolog-h7m","title":"Expand GeologMeta with Derivation proof term syntax","notes":"Add proof term / derivation sorts to GeologMeta.geolog, mirroring Lean's Derivation.lean structure.\n\nProposed sorts:\n- Derivation : Sort\n- Derivation/context : Derivation -\u003e FormulaCtx\n- Derivation/conclusion : Derivation -\u003e Formula\n\nConstructor sorts (each embeds into Derivation):\n- AxiomD, VarD, TrueIntroD, FalseElimD\n- ConjIntroD, ConjElimLD, ConjElimRD  \n- DisjIntroD, DisjElimD\n- EqIntroD, EqElimD\n- ExistsIntroD, ExistsElimD\n\nEach constructor has pointers to sub-derivations and metadata (which axiom, which witness term, etc.)\n\nUse cases:\n1. Query result provenance / explanation\n2. Certified export to Lean for verification\n3. Geometric morphism implementation (need to track HOW formulas map)\n\nDepends on: query engine basics (geolog-7tt) - derivation structure should be informed by what the chase produces.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:58.766688914Z","created_by":"davidad","updated_at":"2026-01-19T15:41:58.766688914Z","dependencies":[{"issue_id":"geolog-h7m","depends_on_id":"geolog-7tt","type":"blocks","created_at":"2026-01-19T15:42:17.885559151Z","created_by":"davidad"},{"issue_id":"geolog-h7m","depends_on_id":"geolog-or6","type":"related","created_at":"2026-01-19T15:42:23.057502465Z","created_by":"davidad"}]}
{"id":"geolog-j0p","title":"Add relation tuple assertion syntax to instances","notes":"Currently instances can only define elements and function values. There's no syntax for asserting relation tuples like 'Edge(a, b)' or '[src: a, tgt: b] Edge'.\n\nProposed syntax options:\n1. `[src: a, tgt: b] Edge;` (record-style)\n2. `Edge(a, b);` (tuple-style)\n3. `:assert Edge(a, b)` (REPL command works but not in instance definition)\n\nThe instance elaboration initializes relation storage (line 117 of instance.rs) but doesn't parse/elaborate relation assertions.\n\nThis would enable testing the chase algorithm with actual edges/paths in the REPL.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T07:32:28.837952002Z","created_by":"davidad","updated_at":"2026-01-20T07:42:21.909825554Z","closed_at":"2026-01-20T07:42:21.909825554Z","close_reason":"Feature already implemented - relation assertions work in instance definitions via syntax '[src: a, tgt: b] Edge;'"}
{"id":"geolog-jho","title":"Support infinitary disjunctions","notes":"core.rs Formula::Disj(Vec\u003cFormula\u003e) only supports finite disjunction. The Lean formalization has:\n\n  infdisj {xs} {I : Set κ} : (I → Formula xs) → Formula xs\n\nwhere κ is a SmallUniverse indexing type.\n\nFor geometric logic completeness, we need infinitary disjunctions. But:\n1. For finite model theory (databases), finite disjunction suffices\n2. Infinitary disjunction matters for: classifying toposes, infinite Skolemization, some program analysis theories\n3. Implementation options: lazy/streaming disjuncts, symbolic index sets\n\nDefer until we have a concrete use case requiring infinite disjunction. Most database/workflow applications will be finite.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:52.067602427Z","created_by":"davidad","updated_at":"2026-01-19T15:41:52.067602427Z"}
{"id":"geolog-k6b","title":"Migrate schema IDs (SortId/FuncId/RelId) to NumericId system","design":"Currently core.rs defines SortId/FuncId/RelId as type aliases to usize. This loses type safety (can confuse sort index with function index).\n\n**Goal:** Replace aliases with proper newtype wrappers using the existing NumericId system in id.rs.\n\n**Scope:**\n1. Add define_id_with_rkyv! for SortId, FuncId, RelId in id.rs\n2. Remove type aliases from core.rs, import from id.rs\n3. Update ~151 call sites to use .index() for Vec indexing or switch to IdVec\n4. Update schema.rs to use Option\u003cSortId\u003e/Option\u003cFuncId\u003e instead of Option\u003cusize\u003e\n5. Update Store API to accept typed IDs\n\n**Alternative:** Use IdVec\u003cSortId, T\u003e instead of Vec\u003cT\u003e for typed indexing.\n\n**Benefits:**\n- Type safety: can't confuse sort index with function index\n- Consistent with project's NumericId philosophy\n- Query engine will benefit from typed IDs\n\n**Blocked by:** Nothing (can be done anytime)\n**Blocks:** Nothing critical (query engine can work with usize for now)","notes":"## Implementation Strategy\n\nAttempted migration on 2026-01-20 night session revealed complexity:\n\n1. **Orphan rules**: Cannot impl `Index\u003cSortId\u003e` for `Vec\u003cT\u003e` since both are foreign types\n2. **Scope**: 96+ usages across codebase require careful migration\n\n### Recommended Approach\n\nOption A: Use `IdVec\u003cSortId, T\u003e` from egglog_numeric_id crate\n- Replace `Vec\u003cT\u003e` with `IdVec\u003cSortId, T\u003e` for Signature fields\n- Provides typed indexing: `sorts[sort_id]` works directly\n- Downside: Need to update all structure fields\n\nOption B: Newtype pattern with Deref\n- Create wrapper struct that derefs to the underlying storage\n- E.g., `struct SortVec\u003cT\u003e(Vec\u003cT\u003e)` with `Index\u003cSortId\u003e` impl\n- Can incrementally adopt\n\nOption C: Macro-based conversion\n- Add helper macro that expands `sorts[id]` to `sorts[id.index()]`\n- Minimal code changes, but non-standard\n\n### Files requiring changes\n- src/core.rs (Signature, Structure definitions)\n- src/store/schema.rs (schema ID caches)\n- src/elaborate/*.rs (theory/instance elaboration)\n- src/query/*.rs (query compilation)\n- src/tensor/*.rs (formula compilation)\n- tests/*.rs (generators and tests)\n\n**Recommended**: Do this as a dedicated refactoring session with good test coverage.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T21:41:06.946314946Z","created_by":"davidad","updated_at":"2026-01-20T00:35:55.958331277Z"}
{"id":"geolog-lbn","title":"Consider de Bruijn indices for Term representation","notes":"core.rs Term::Var uses names (String, DerivedSort) for 'debuggability'. The Lean formalization uses positional indices for alpha-equivalence.\n\nQuestions to resolve:\n1. Do we need alpha-equivalence in the Rust implementation? (Probably not - we're querying concrete instances, not proving metatheorems)\n2. If we do need term comparison, could hash-cons with explicit name binding be enough?\n3. Performance: String comparison vs integer comparison in hot paths\n\nCurrent assessment: Names are probably fine for an implementation focused on query evaluation. de Bruijn would matter more if we were implementing a proof checker or term rewriter. Low priority unless profiling shows name comparison is a bottleneck.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:41:46.343016685Z","created_by":"davidad","updated_at":"2026-01-19T15:41:46.343016685Z"}
{"id":"geolog-ltk","title":"Chase/tensor don't support universal conclusion axioms","design":"RelAlgIR has axioms like 'ax/equiv/refl : forall w : Wire. |- [a: w, b: w] equiv' which have True as premise and derive facts for all elements of a sort. Neither chase nor tensor checking can handle these patterns currently. Chase compilation fails on function application patterns, and even when that's skipped, the tensor checker finds violations because these derived relations aren't populated. Potential solutions: 1) Extend chase to handle universal conclusions (iterate over domain and add derived tuples), 2) Add special handling for 'True premise' axioms, 3) Allow 'unchecked' instances. For now, test_relalg_simple_examples is ignored.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T15:07:04.262956603Z","created_by":"davidad","updated_at":"2026-01-20T15:07:04.262956603Z"}
{"id":"geolog-m0c","title":"Product domain support across codebase","notes":"## 2026-01-20 Product Codomain Implementation COMPLETE\n\n### What Was Implemented\n1. **FunctionColumn::ProductCodomain** variant in core.rs\n   - Field-per-column storage for product codomains\n   - FunctionFullInfo and FunctionCodomainInfo types\n   - init_functions_complete() for full domain+codomain init\n   - define_function_product_codomain() and get_function_product_codomain()\n\n2. **Instance Elaboration** (elaborate/instance.rs)\n   - Detects product codomains during initialization  \n   - Parses Record RHS for product codomain assignments\n   - Type checks each field value against expected sort\n\n3. **Display Support** (repl.rs)\n   - Shows product codomain values as \\`elem func = [field: val, ...]\\`\n\n4. **Serialization** (serialize.rs)\n   - Serialize/deserialize ProductCodomain function columns\n\n### Test Files Added\n- product_codomain_test.geolog - Basic product codomain examples\n- petri_trace_test.geolog - Trace theory with product codomain wire endpoints\n- petri_reachability_vision.geolog - Full reachability problem setup\n\n### Working Example\n\\`\\`\\`\ntheory (N : PetriNet instance) Trace {\n  W/src : W -\u003e [firing : F, arc : N/out];\n  ...\n}\ninstance SimpleTrace : SimpleNet Trace = {\n  it input_terminal/tgt = [firing: f1, arc: SimpleNet/arc_in];\n}\n\\`\\`\\`\n\n### Remaining for Full Vision\n- Product codomain values in existential formulas\n- Product codomain equality in axiom premises","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:24.715123749Z","created_by":"davidad","updated_at":"2026-01-20T16:09:13.909226155Z","dependencies":[{"issue_id":"geolog-m0c","depends_on_id":"geolog-7cc","type":"related","created_at":"2026-01-19T15:52:07.893037101Z","created_by":"davidad"}]}
{"id":"geolog-or6","title":"Derivations as meta-embedded proof terms","design":"Proof terms for geometric sequents, meta-embedded like GeologMeta. Key design questions:\n\n1. When are explicit derivations needed?\n   - Provenance/explanation of query results\n   - Certified export to Lean for verification  \n   - Theory morphisms that track formula mappings\n   - NOT needed for basic query evaluation (proofs are implicit in computation)\n\n2. Structure mirrors Lean Derivation.lean:\n   - Derivation : FormulaContext × Formula → Sort\n   - Constructors: axiom, var, true_intro, false_elim, conj_intro/elim, disj_intro/elim, eq_intro/elim, exists_intro/elim\n\n3. Meta-embedding options:\n   - Expand GeologMeta with Derivation sorts\n   - Separate GeologDerivation theory parameterized by GeologMeta instance\n\n4. Geometric morphisms connection:\n   - A geometric morphism T₁ → T₂ induces derivation translation\n   - Need derivations to track HOW formulas map, not just THAT they do\n\nDefer until query engine basics work.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:38:01.777111215Z","created_by":"davidad","updated_at":"2026-01-19T15:38:01.777111215Z","dependencies":[{"issue_id":"geolog-or6","depends_on_id":"geolog-7tt","type":"blocks","created_at":"2026-01-19T15:42:05.031285391Z","created_by":"davidad"}]}
{"id":"geolog-p1s","title":"Fix :assert command to find relations within theories","notes":":assert Triangle Edge a b fails because resolve_name() only finds top-level elements, not relations defined within a theory.\n\nAlso, :assert only supports single-argument relations currently (line 482 check). Multi-argument relations like Edge(src, tgt) are common.\n\nFix requires:\n1. Look up the instance's theory to find the relation\n2. Support multi-argument relations (tuples)\n3. Handle product domain relations properly\n\nRelated to geolog-j0p (relation assertion syntax in instances).","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T07:33:09.064345725Z","created_by":"davidad","updated_at":"2026-01-20T07:36:09.400610542Z","closed_at":"2026-01-20T07:36:09.400610542Z","close_reason":"Fixed: :assert now looks up relations in theory signature and elements in entry.element_names"}
{"id":"geolog-py9","title":"Solver search infrastructure","description":"Design the core search API: Goal representation (geometric sequent to witness), SearchState (partial assignments, undo trail), Tactic trait for composable search strategies. This is the foundation for the agent-driven solver davidad envisions. Key references: Knuth 4B Algorithm D, Floyd's reversible memory (Fascicle 7), Logic-Based Benders decomposition.","notes":"Updated solver.rs with corrected semantics:\n\nCRITICAL FIX: Axiom violations are OBLIGATIONS, not unsat!\n- In geometric logic, consequents are positive (∃, ∨, atomic)\n- Violation = premise satisfied, conclusion not yet witnessed\n- Obligation can ALWAYS potentially be fulfilled by refinement\n- Only CONFLICT (fulfilling would contradict existing commitment) is unsat\n\nChanges made:\n- Added Obligation type (axiom_idx, assignment, description)\n- Added AxiomCheckResult enum (AllSatisfied | Obligations)\n- Renamed PropagationTactic → CheckTactic\n- CheckTactic returns HasObligations instead of marking unsat\n- TacticResult now has HasObligations variant\n- Updated module docs explaining obligations vs conflicts\n\nThis is essentially Datalog-style forward chaining over partial models:\nobligations create pressure to add facts until fixpoint.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T00:44:35.446782775Z","updated_at":"2025-12-15T04:04:25.05768285Z","closed_at":"2025-12-15T04:04:25.05768285Z","dependencies":[{"issue_id":"geolog-py9","depends_on_id":"geolog-9k9","type":"blocks","created_at":"2025-12-15T00:48:34.514918958Z","created_by":"dev"},{"issue_id":"geolog-py9","depends_on_id":"geolog-0vd","type":"blocks","created_at":"2025-12-15T02:09:34.101961199Z","created_by":"dev"}]}
{"id":"geolog-q2x","title":"Axioms hidden in :inspect output","description":"When inspecting a theory with axioms, the axiom definitions are not shown - only a comment indicating how many axioms exist.\n\nExample:\n```\ntheory Iso {\n    X : Sort;\n    Y : Sort;\n    fwd : X -\u003e Y;\n    bwd : Y -\u003e X;\n    fb : forall x : X. |- x fwd bwd = x;\n}\n\n:inspect Iso\nOutput shows: // 1 axiom(s)\nExpected: Show the actual axiom: fb : forall x : X. |- x fwd bwd = x;\n```\n\nUsers need to see the actual axiom definitions to understand the theory's constraints.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:24.401432952Z","updated_at":"2025-12-15T00:01:37.378995078Z","closed_at":"2025-12-15T00:01:37.378995078Z"}
{"id":"geolog-qo3","title":"Forward chaining tactic","description":"Implement a tactic that automatically fulfills simple obligations: when an axiom's consequent is an existential or relation assertion, try to witness it. This is Datalog-style forward chaining. Should integrate with congruence closure for equation consequents.","notes":"## Recursive Existential Body Processing (2026-01-20 ~03:45 UTC)\n\nAdded FormulaProcessor helper for recursive formula processing:\n- Existential bodies are now properly processed after adding witnesses\n- Nested existentials like ∃x.∃y.R(x,y) work correctly\n- Conjunctions in bodies are handled recursively\n- Disjunctions in branches get their own FormulaProcessor\n\nTest coverage:\n- test_existential_body_processing: ∃x.R(x)\n- test_nested_existential_body: ∃x.∃y.E(x,y)\n\nRemaining work:\n- Product domain existentials\n- Full proof term tracking","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T04:06:31.457694883Z","updated_at":"2026-01-20T03:21:50.167521652Z","closed_at":"2026-01-20T03:21:50.167521652Z","close_reason":"Core forward chaining implemented: ForwardChainingTactic, PropagateEquationsTactic, AutoTactic, recursive existential body processing. Product domains and proof term tracking deferred to separate tasks.","dependencies":[{"issue_id":"geolog-qo3","depends_on_id":"geolog-xj2","type":"parent-child","created_at":"2025-12-15T04:07:08.941041676Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-7rn","type":"blocks","created_at":"2025-12-15T04:07:29.726008313Z","created_by":"dev"},{"issue_id":"geolog-qo3","depends_on_id":"geolog-fjy","type":"blocks","created_at":"2025-12-15T04:07:34.793149209Z","created_by":"dev"}]}
{"id":"geolog-qw8","title":"Nested instance definitions in instance bodies","notes":"The original design (loose_thoughts/2025-12-12_12:10.md) uses nested instance syntax for defining sub-instances inline. AST has InstanceItem::NestedInstance but parser doesn't handle 'name = { ... }' syntax. Required: parser changes, elaboration handling, store persistence.","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:40:44.031641462Z","created_by":"davidad","updated_at":"2026-01-20T09:53:55.001019909Z","closed_at":"2026-01-20T09:53:55.001019909Z","close_reason":"Implemented nested instance definitions with full elaboration support"}
{"id":"geolog-rgg","title":"Prove Monotonic Submodel Property in Lean","design":"GeologMeta.geolog claims the Monotonic Submodel Property holds due to function/relation immutability. This should be formally verified in the Lean formalization (model-theory-topos). The property states that adding elements to a structure preserves all existing query results - crucial for incremental/concurrent evaluation. Coordinate with the existing ModelTheoryTopos/Geometric/ code.","notes":"## 2026-01-20 Progress\\nConverted several axioms to definitions:\\n- liftSort: now a noncomputable def\\n- liftEmbedContext: now a noncomputable def\\n- Added Types_productIso lemmas\\n\\nRemaining sorries need Type u unification work.","status":"in_progress","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:49.258523317Z","created_by":"davidad","updated_at":"2026-01-20T03:49:53.163342426Z"}
{"id":"geolog-ryc","title":"Higher-order application in elaboration","notes":"src/elaborate/env.rs:139 - When elaborating term application where the function position isn't a known function symbol:\n\n  // Higher-order application — not supported yet\n  Err(ElabError::UnsupportedFeature('higher-order application'))\n\nThis would be needed for first-class functions / dependent types. Low priority for geometric logic which doesn't need this.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:51:50.763960529Z","created_by":"davidad","updated_at":"2026-01-19T15:51:50.763960529Z"}
{"id":"geolog-ubi","title":"Replace bootstrap_queries with proper query engine","notes":"The bootstrap_queries.rs file contains hardcoded query methods (query_theory_sorts, query_theory_funcs, etc.) that should be replaced with proper query engine calls once geolog-7tt is complete.","status":"open","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T16:29:52.582051917Z","created_by":"davidad","updated_at":"2026-01-19T16:29:52.582051917Z","dependencies":[{"issue_id":"geolog-ubi","depends_on_id":"geolog-7tt","type":"blocks","created_at":"2026-01-19T16:30:02.048113547Z","created_by":"davidad"}]}
{"id":"geolog-ulh","title":"Product-typed function application in instance equations","design":"Instance elaboration fails when equations reference functions with product domains using record literals, e.g. `[x: a, y: b] mul = c`. Error: 'unsupported feature: complex element reference'. Need to extend elaborate/instance.rs to handle Record terms in equation LHS positions by: (1) evaluating the record to build the product-typed argument, (2) looking up or creating the function application result.","notes":"Discovered while creating examples/geolog/monoid.geolog - tried to write:\n\n```\ninstance TrivialMonoid : Monoid = {\n  u : M;\n  [unit: []] e = u;        // \u003c- fails here\n  [x: u, y: u] mul = u;    // \u003c- and here\n}\n```\n\nThe elaborator sees Record([...]) in the LHS and bails with 'unsupported feature'.\n\nRelated to function evaluation during instance elaboration - need to:\n1. Recognize when LHS is a function application with product domain\n2. Build the product-typed argument from the Record\n3. Register the function mapping","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T00:27:00.904154649Z","created_by":"davidad","updated_at":"2026-01-19T00:56:56.100838432Z","closed_at":"2026-01-19T00:56:56.100838432Z","close_reason":"Implemented product-typed function application in instance equations. Added FunctionColumn::ProductLocal variant with nested Vec storage (Binary/Ternary/General), updated instance elaboration to handle Record terms in equation LHS, updated REPL inspect command to display product domain values. Full test coverage added. monoid.geolog now works with Trivial, BoolAnd, and BoolOr instances."}
{"id":"geolog-vqz","title":"Existential quantification in chase conclusions","notes":"Original design has axioms like: ax5 : forall f : F, arc : N/out. arc out/src = f F/of |- (exists w : W. w W/src = [firing: f, arc: arc]). Chase must create new elements when existentials fire. Currently loops infinitely. Required: detect existential conclusions, generate fresh elements, add to structure.","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:41:04.349500956Z","created_by":"davidad","updated_at":"2026-01-20T10:01:50.543091752Z","closed_at":"2026-01-20T10:01:50.543091752Z","close_reason":"Implemented skolem-style chase for existential conclusions with EnsureFunction pattern"}
{"id":"geolog-vzh","title":"Fix Box::leak memory leak in MetaReader::new","design":"In src/meta.rs, MetaReader::new() uses Box::leak(Box::new(meta.theory.signature.clone())) to extend the lifetime of the signature. This leaks memory on every call. Should instead store Arc\u003cElaboratedTheory\u003e or use a lifetime parameter to borrow from the caller's Arc.","notes":"In src/meta.rs line ~641: sig: Box::leak(Box::new(meta.theory.signature.clone())). Should store Arc\u003cElaboratedTheory\u003e directly or use lifetime parameter.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-19T15:37:43.489090254Z","created_by":"davidad","updated_at":"2026-01-19T15:46:55.671253625Z","closed_at":"2026-01-19T15:46:55.671253625Z","close_reason":"Fixed: MetaReader now stores Arc\u003cElaboratedTheory\u003e instead of leaking cloned Signature"}
{"id":"geolog-w7a","title":"Duplicate instance names silently overwrite","description":"Defining an instance with a name that already exists silently replaces the old instance without any warning or error.\n\nExample:\n```\ntheory T { X : Sort; }\ninstance I1 : T = { a : X; }\ninstance I1 : T = { b : X; }  // Silently replaces the first I1\n```\n\nSame issue as with duplicate theory names - users should be warned about overwrites.\n\nLocation: src/repl.rs (execute_geolog, instance registration)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:44:58.373441794Z","updated_at":"2025-12-15T00:02:14.722840298Z","closed_at":"2025-12-15T00:02:14.722840298Z"}
{"id":"geolog-w8m","title":"Property-based testing with proptest","description":"From ROADMAP.md: Generate random ASTs, print, re-parse, compare. Some proptest infrastructure exists in tests/generators.rs but is mostly unused.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:11.022184496Z","updated_at":"2025-12-15T03:08:24.678221459Z","closed_at":"2025-12-15T03:08:24.678221459Z"}
{"id":"geolog-xj2","title":"Complete geometric logic solver","description":"Full solver implementation for instance synthesis. Builds on py9's SearchTree infrastructure. Needs congruence closure for equation handling, derivation search for unsat detection, and integration with REPL queries.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T04:05:17.492342994Z","updated_at":"2026-01-20T03:22:40.265422365Z","closed_at":"2026-01-20T03:22:40.265422365Z","close_reason":"Geometric logic solver complete: SearchTree, CongruenceClosure, ForwardChainingTactic, PropagateEquationsTactic, AutoTactic, derivation search for False. All children tasks (7rn, dkk, fjy, qo3) completed. REPL integration tracked separately in 5zt."}
{"id":"geolog-xsr","title":"Ariadne error messages","description":"From ROADMAP.md: Pretty error reporting with source spans. The ariadne crate is already in Cargo.toml but not used yet.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T00:49:20.060918294Z","updated_at":"2025-12-15T00:49:20.060918294Z"}
{"id":"geolog-xte","title":"Parse errors are cryptic and show internal token names","description":"When a parse error occurs, the error message shows internal token representations that are not user-friendly.\n\nExample:\n```\ntheory BadSyntax {\n    X : Sort\n    Y : Sort;  // Missing semicolon after X\n}\n\nError: Parser errors: [Simple { span: 38..39, reason: Unexpected, expected: {Some(Sort), Some(LParen), Some(LBracket), Some(Instance), Some(Semicolon), Some(Slash), Some(Arrow)}, found: Some(Colon), label: None }]\n```\n\nExpected: 'Error: Expected semicolon after sort declaration on line 2, found \":\"'\n\nThe error should be human-readable and point to the specific location with line/column numbers.\n\nLocation: src/parser.rs or src/lexer.rs (error reporting using chumsky's error handling)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T22:45:19.886462562Z","updated_at":"2025-12-14T23:01:59.353326107Z","closed_at":"2025-12-14T23:01:59.353328107Z"}
{"id":"geolog-xw5","title":"Relations completely omitted from :inspect output","description":"When inspecting a theory that includes relations, the relations are completely omitted from the output.\n\nExample:\n```\ntheory WithRelation {\n    X : Sort;\n    R : [x : X, y : X] Relation;\n}\n\n:inspect WithRelation\nOutput shows only: X : Sort;\nExpected: Should also show R : [x : X, y : X] Relation;\n```\n\nRelations are a first-class part of the theory signature but are invisible in the REPL output.\n\nLocation: src/repl.rs (theory formatting) or src/pretty.rs","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T22:45:38.560834631Z","updated_at":"2025-12-15T00:01:46.509652398Z","closed_at":"2025-12-15T00:01:46.509652398Z"}
{"id":"geolog-yi1","title":"Parameterized instance elaboration","description":"elaborate_instance currently returns 'unsupported feature: parameterized instance types' for types like 'N Marking instance' where N is a parameter. Need to handle theory application and instantiate the parameterized signature with concrete arguments.","notes":"## 2026-01-20 Progress\n\ncommit d917c6d: Fix element name display for parameterized instances\n\nParameterized instances now display imported element names correctly!\nBefore: `#0`, `#1`, `#2` for imported elements\nAfter: `Net/place1`, `Net/place2`, `Net/trans1`\n\nThe fix returns `InstanceElaborationResult` from `elaborate_instance_ctx`\ncontaining both the structure AND the element name mappings, which the\nREPL then uses to properly track all element names.\n\nRemaining work:\n- Nested parameterized theories (multiple params) still need work\n- DBSP incremental operators","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T00:44:57.147063688Z","updated_at":"2026-01-20T01:33:22.83185319Z","closed_at":"2026-01-20T01:33:22.83185319Z","close_reason":"Nested parameterized theories now work. M/N/X naming is correct.","dependencies":[{"issue_id":"geolog-yi1","depends_on_id":"geolog-8z9","type":"related","created_at":"2025-12-15T09:42:03.47134483Z","created_by":"dev"}]}
{"id":"geolog-yr2","title":"Sort parameters for parameterized theories","notes":"Original vision has 'theory (X : Sort) (Y : Sort) Iso' - theories parameterized by sorts (not instances). Currently we only support instance parameters like 'theory (N : PetriNet instance) Marking'. Need to extend parameter system to handle Sort-typed parameters. These are simpler than instance params - they just introduce a sort variable that can be used in the theory body.","status":"closed","priority":2,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T11:29:03.703648677Z","created_by":"davidad","updated_at":"2026-01-20T11:43:18.001635137Z","closed_at":"2026-01-20T11:43:18.001635137Z","close_reason":"Already implemented: Sort parameters work correctly. Test: 'theory (X : Sort) (Y : Sort) Iso { fwd : X -\u003e Y; bwd : Y -\u003e X; ... }' elaborates and works as expected."}
{"id":"geolog-zlw","title":"Query solving implementation","notes":"Progress: Fixed two key issues:\n1. build_query_base now imports function values from param instances (not just elements)\n2. enumerate_models no longer overwrites pre-initialized function storage\n\nParameterized queries now work:\n- query { ? : TestNet Marking instance; } finds a valid Marking (empty, with no tokens)\n- Function values from the base instance are preserved in the solver","status":"closed","priority":1,"issue_type":"task","owner":"davidad@alum.mit.edu","created_at":"2026-01-20T09:42:07.996293321Z","created_by":"davidad","updated_at":"2026-01-20T15:47:47.306420412Z","closed_at":"2026-01-20T15:47:47.306420412Z","close_reason":"Implemented: Parameterized queries work. Fixed function value import and storage preservation."}
