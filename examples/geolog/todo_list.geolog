// TodoList: A simple relational model for tracking tasks
//
// This demonstrates geolog as a persistent relational database.
// Elements represent tasks, and relations track their status.

theory TodoList {
  // The sort of todo items
  Item : Sort;

  // Unary relations for item status (using named field syntax)
  completed : [item: Item] -> Prop;      // Item has been completed
  high_priority : [item: Item] -> Prop;  // Item is high priority
  blocked : [item: Item] -> Prop;        // Item is blocked on something

  // Binary relation for dependencies
  depends_on : [x: Item, y: Item] -> Prop;  // x depends on y (x is blocked until y is done)

  // Axiom: if an item depends on an incomplete item, it's blocked
  // Note: We use two separate axioms instead of a disjunction because
  // the tensor compiler currently requires disjuncts to have the same
  // free variables. See geolog-69b for this limitation.
  //
  // Original: [x: x, y: y] depends_on |- [item: x] blocked \/ [item: y] completed
  // Split into contrapositive implications:

  // If x depends on y, and y is not completed, then x is blocked
  // (We can't express "not completed" directly, so we use a different formulation)
  // For now, we just say: dependencies imply blocked status
  ax/dep_blocked : forall x : Item, y : Item.
    [x: x, y: y] depends_on |- [item: x] blocked;
}

// Example: An empty todo list ready for interactive use
instance MyTodos : TodoList = {
  // Start empty - add items interactively with :add
}

// Example: A pre-populated todo list
instance SampleTodos : TodoList = {
  // Items
  buy_groceries : Item;
  cook_dinner : Item;
  do_laundry : Item;
  clean_house : Item;

  // Status: unary relations use simple syntax
  buy_groceries completed;
  cook_dinner high_priority;

  // Dependencies: cook_dinner depends on buy_groceries
  [x: cook_dinner, y: buy_groceries] depends_on;
}
